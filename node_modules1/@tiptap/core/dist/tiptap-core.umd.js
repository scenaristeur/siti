(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('prosemirror-state'), require('prosemirror-view'), require('prosemirror-model'), require('prosemirror-keymap'), require('prosemirror-inputrules'), require('prosemirror-transform'), require('prosemirror-commands'), require('prosemirror-schema-list')) :
  typeof define === 'function' && define.amd ? define(['exports', 'prosemirror-state', 'prosemirror-view', 'prosemirror-model', 'prosemirror-keymap', 'prosemirror-inputrules', 'prosemirror-transform', 'prosemirror-commands', 'prosemirror-schema-list'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@tiptap/core'] = {}, global.prosemirrorState, global.prosemirrorView, global.prosemirrorModel, global.prosemirrorKeymap, global.prosemirrorInputrules, global.prosemirrorTransform, global.prosemirrorCommands, global.prosemirrorSchemaList));
}(this, (function (exports, prosemirrorState, prosemirrorView, prosemirrorModel, prosemirrorKeymap, prosemirrorInputrules, prosemirrorTransform, prosemirrorCommands, prosemirrorSchemaList) { 'use strict';

  function getSchemaTypeNameByName(name, schema) {
      if (schema.nodes[name]) {
          return 'node';
      }
      if (schema.marks[name]) {
          return 'mark';
      }
      return null;
  }

  function getNodeType(nameOrType, schema) {
      if (typeof nameOrType === 'string') {
          if (!schema.nodes[nameOrType]) {
              throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
          }
          return schema.nodes[nameOrType];
      }
      return nameOrType;
  }

  function getNodeAttributes(state, typeOrName) {
      const type = getNodeType(typeOrName, state.schema);
      const { from, to } = state.selection;
      let nodes = [];
      state.doc.nodesBetween(from, to, node => {
          nodes = [...nodes, node];
      });
      const node = nodes
          .reverse()
          .find(nodeItem => nodeItem.type.name === type.name);
      if (node) {
          return { ...node.attrs };
      }
      return {};
  }

  function getMarkType(nameOrType, schema) {
      if (typeof nameOrType === 'string') {
          if (!schema.marks[nameOrType]) {
              throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
          }
          return schema.marks[nameOrType];
      }
      return nameOrType;
  }

  function getMarkAttributes(state, typeOrName) {
      const type = getMarkType(typeOrName, state.schema);
      const { from, to, empty } = state.selection;
      let marks = [];
      if (empty) {
          marks = state.selection.$head.marks();
      }
      else {
          state.doc.nodesBetween(from, to, node => {
              marks = [...marks, ...node.marks];
          });
      }
      const mark = marks.find(markItem => markItem.type.name === type.name);
      if (mark) {
          return { ...mark.attrs };
      }
      return {};
  }

  function getAttributes(state, typeOrName) {
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'
          ? typeOrName
          : typeOrName.name, state.schema);
      if (schemaType === 'node') {
          return getNodeAttributes(state, typeOrName);
      }
      if (schemaType === 'mark') {
          return getMarkAttributes(state, typeOrName);
      }
      return {};
  }

  /**
   * Check if object1 includes object2
   * @param object1 Object
   * @param object2 Object
   */
  function objectIncludes(object1, object2) {
      const keys = Object.keys(object2);
      if (!keys.length) {
          return true;
      }
      return !!keys
          .filter(key => object2[key] === object1[key])
          .length;
  }

  function isNodeActive(state, typeOrName, attributes = {}) {
      const { from, to, empty } = state.selection;
      const type = typeOrName
          ? getNodeType(typeOrName, state.schema)
          : null;
      let nodeRanges = [];
      state.doc.nodesBetween(from, to, (node, pos) => {
          if (!node.isText) {
              const relativeFrom = Math.max(from, pos);
              const relativeTo = Math.min(to, pos + node.nodeSize);
              nodeRanges = [...nodeRanges, {
                      node,
                      from: relativeFrom,
                      to: relativeTo,
                  }];
          }
      });
      if (empty) {
          return !!nodeRanges
              .filter(nodeRange => {
              if (!type) {
                  return true;
              }
              return type.name === nodeRange.node.type.name;
          })
              .find(nodeRange => objectIncludes(nodeRange.node.attrs, attributes));
      }
      const selectionRange = to - from;
      const range = nodeRanges
          .filter(nodeRange => {
          if (!type) {
              return true;
          }
          return type.name === nodeRange.node.type.name;
      })
          .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes))
          .reduce((sum, nodeRange) => {
          const size = nodeRange.to - nodeRange.from;
          return sum + size;
      }, 0);
      return range >= selectionRange;
  }

  function isMarkActive(state, typeOrName, attributes = {}) {
      const { from, to, empty } = state.selection;
      const type = typeOrName
          ? getMarkType(typeOrName, state.schema)
          : null;
      if (empty) {
          return !!(state.storedMarks || state.selection.$from.marks())
              .filter(mark => {
              if (!type) {
                  return true;
              }
              return type.name === mark.type.name;
          })
              .find(mark => objectIncludes(mark.attrs, attributes));
      }
      let selectionRange = 0;
      let markRanges = [];
      state.doc.nodesBetween(from, to, (node, pos) => {
          if (node.isText) {
              const relativeFrom = Math.max(from, pos);
              const relativeTo = Math.min(to, pos + node.nodeSize);
              const range = relativeTo - relativeFrom;
              selectionRange += range;
              markRanges = [...markRanges, ...node.marks.map(mark => ({
                      mark,
                      from: relativeFrom,
                      to: relativeTo,
                  }))];
          }
      });
      if (selectionRange === 0) {
          return false;
      }
      // calculate range of matched mark
      const matchedRange = markRanges
          .filter(markRange => {
          if (!type) {
              return true;
          }
          return type.name === markRange.mark.type.name;
      })
          .filter(markRange => objectIncludes(markRange.mark.attrs, attributes))
          .reduce((sum, markRange) => {
          const size = markRange.to - markRange.from;
          return sum + size;
      }, 0);
      // calculate range of marks that excludes the searched mark
      // for example `code` doesnâ€™t allow any other marks
      const excludedRange = markRanges
          .filter(markRange => {
          if (!type) {
              return true;
          }
          return markRange.mark.type !== type
              && markRange.mark.type.excludes(type);
      })
          .reduce((sum, markRange) => {
          const size = markRange.to - markRange.from;
          return sum + size;
      }, 0);
      // we only include the result of `excludedRange`
      // if there is a match at all
      const range = matchedRange > 0
          ? matchedRange + excludedRange
          : matchedRange;
      return range >= selectionRange;
  }

  function isActive(state, name, attributes = {}) {
      if (!name) {
          return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
      }
      const schemaType = getSchemaTypeNameByName(name, state.schema);
      if (schemaType === 'node') {
          return isNodeActive(state, name, attributes);
      }
      if (schemaType === 'mark') {
          return isMarkActive(state, name, attributes);
      }
      return false;
  }

  function removeElement(element) {
      if (element && element.parentNode) {
          element.parentNode.removeChild(element);
      }
  }

  function elementFromString(value) {
      // add a wrapper to preserve leading and trailing whitespace
      const wrappedValue = `<body>${value}</body>`;
      return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;
  }

  function createNodeFromContent(content, schema, options) {
      options = {
          slice: true,
          parseOptions: {},
          ...options,
      };
      if (typeof content === 'object' && content !== null) {
          try {
              if (Array.isArray(content)) {
                  return prosemirrorModel.Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));
              }
              return schema.nodeFromJSON(content);
          }
          catch (error) {
              console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);
              return createNodeFromContent('', schema, options);
          }
      }
      if (typeof content === 'string') {
          const parser = prosemirrorModel.DOMParser.fromSchema(schema);
          return options.slice
              ? parser.parseSlice(elementFromString(content), options.parseOptions).content
              : parser.parse(elementFromString(content), options.parseOptions);
      }
      return createNodeFromContent('', schema, options);
  }

  function createDocument(content, schema, parseOptions = {}) {
      return createNodeFromContent(content, schema, { slice: false, parseOptions });
  }

  function getHTMLFromFragment(doc, schema) {
      const fragment = prosemirrorModel.DOMSerializer
          .fromSchema(schema)
          .serializeFragment(doc.content);
      const temporaryDocument = document.implementation.createHTMLDocument();
      const container = temporaryDocument.createElement('div');
      container.appendChild(fragment);
      return container.innerHTML;
  }

  function isNodeEmpty(node) {
      var _a;
      const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
      const content = node.toJSON();
      return JSON.stringify(defaultContent) === JSON.stringify(content);
  }

  function createStyleTag(style) {
      const tipTapStyleTag = document.querySelector('style[data-tiptap-style]');
      if (tipTapStyleTag !== null) {
          return tipTapStyleTag;
      }
      const styleNode = document.createElement('style');
      styleNode.setAttribute('data-tiptap-style', '');
      styleNode.innerHTML = style;
      document.getElementsByTagName('head')[0].appendChild(styleNode);
      return styleNode;
  }

  class CommandManager {
      constructor(editor, commands) {
          this.editor = editor;
          this.commands = commands;
      }
      createCommands() {
          const { commands, editor } = this;
          const { state, view } = editor;
          const { tr } = state;
          const props = this.buildProps(tr);
          return Object.fromEntries(Object
              .entries(commands)
              .map(([name, command]) => {
              const method = (...args) => {
                  const callback = command(...args)(props);
                  if (!tr.getMeta('preventDispatch')) {
                      view.dispatch(tr);
                  }
                  return callback;
              };
              return [name, method];
          }));
      }
      createChain(startTr, shouldDispatch = true) {
          const { commands, editor } = this;
          const { state, view } = editor;
          const callbacks = [];
          const hasStartTransaction = !!startTr;
          const tr = startTr || state.tr;
          const run = () => {
              if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch')) {
                  view.dispatch(tr);
              }
              return callbacks.every(callback => callback === true);
          };
          const chain = {
              ...Object.fromEntries(Object.entries(commands).map(([name, command]) => {
                  const chainedCommand = (...args) => {
                      const props = this.buildProps(tr, shouldDispatch);
                      const callback = command(...args)(props);
                      callbacks.push(callback);
                      return chain;
                  };
                  return [name, chainedCommand];
              })),
              run,
          };
          return chain;
      }
      createCan(startTr) {
          const { commands, editor } = this;
          const { state } = editor;
          const dispatch = undefined;
          const tr = startTr || state.tr;
          const props = this.buildProps(tr, dispatch);
          const formattedCommands = Object.fromEntries(Object
              .entries(commands)
              .map(([name, command]) => {
              return [name, (...args) => command(...args)({ ...props, dispatch })];
          }));
          return {
              ...formattedCommands,
              chain: () => this.createChain(tr, dispatch),
          };
      }
      buildProps(tr, shouldDispatch = true) {
          const { editor, commands } = this;
          const { state, view } = editor;
          if (state.storedMarks) {
              tr.setStoredMarks(state.storedMarks);
          }
          const props = {
              tr,
              editor,
              view,
              state: this.chainableState(tr, state),
              dispatch: shouldDispatch
                  ? () => undefined
                  : undefined,
              chain: () => this.createChain(tr),
              can: () => this.createCan(tr),
              get commands() {
                  return Object.fromEntries(Object
                      .entries(commands)
                      .map(([name, command]) => {
                      return [name, (...args) => command(...args)(props)];
                  }));
              },
          };
          return props;
      }
      chainableState(tr, state) {
          let { selection } = tr;
          let { doc } = tr;
          let { storedMarks } = tr;
          return {
              ...state,
              schema: state.schema,
              plugins: state.plugins,
              apply: state.apply.bind(state),
              applyTransaction: state.applyTransaction.bind(state),
              reconfigure: state.reconfigure.bind(state),
              toJSON: state.toJSON.bind(state),
              get storedMarks() {
                  return storedMarks;
              },
              get selection() {
                  return selection;
              },
              get doc() {
                  return doc;
              },
              get tr() {
                  selection = tr.selection;
                  doc = tr.doc;
                  storedMarks = tr.storedMarks;
                  return tr;
              },
          };
      }
  }

  function getExtensionField(extension, field, context = {}) {
      if (extension.config[field] === undefined && extension.parent) {
          return getExtensionField(extension.parent, field, context);
      }
      if (typeof extension.config[field] === 'function') {
          const value = extension.config[field].bind({
              ...context,
              parent: extension.parent
                  ? getExtensionField(extension.parent, field, context)
                  : null,
          });
          return value;
      }
      return extension.config[field];
  }

  function splitExtensions(extensions) {
      const baseExtensions = extensions.filter(extension => extension.type === 'extension');
      const nodeExtensions = extensions.filter(extension => extension.type === 'node');
      const markExtensions = extensions.filter(extension => extension.type === 'mark');
      return {
          baseExtensions,
          nodeExtensions,
          markExtensions,
      };
  }

  /**
   * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.
   * @param extensions List of extensions
   */
  function getAttributesFromExtensions(extensions) {
      const extensionAttributes = [];
      const { nodeExtensions, markExtensions } = splitExtensions(extensions);
      const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
      const defaultAttribute = {
          default: null,
          rendered: true,
          renderHTML: null,
          parseHTML: null,
          keepOnSplit: true,
      };
      extensions.forEach(extension => {
          const context = {
              name: extension.name,
              options: extension.options,
          };
          const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);
          if (!addGlobalAttributes) {
              return;
          }
          // TODO: remove `as GlobalAttributes`
          const globalAttributes = addGlobalAttributes();
          globalAttributes.forEach(globalAttribute => {
              globalAttribute.types.forEach(type => {
                  Object
                      .entries(globalAttribute.attributes)
                      .forEach(([name, attribute]) => {
                      extensionAttributes.push({
                          type,
                          name,
                          attribute: {
                              ...defaultAttribute,
                              ...attribute,
                          },
                      });
                  });
              });
          });
      });
      nodeAndMarkExtensions.forEach(extension => {
          const context = {
              name: extension.name,
              options: extension.options,
          };
          const addAttributes = getExtensionField(extension, 'addAttributes', context);
          if (!addAttributes) {
              return;
          }
          // TODO: remove `as Attributes`
          const attributes = addAttributes();
          Object
              .entries(attributes)
              .forEach(([name, attribute]) => {
              extensionAttributes.push({
                  type: extension.name,
                  name,
                  attribute: {
                      ...defaultAttribute,
                      ...attribute,
                  },
              });
          });
      });
      return extensionAttributes;
  }

  function mergeAttributes(...objects) {
      return objects
          .filter(item => !!item)
          .reduce((items, item) => {
          const mergedAttributes = { ...items };
          Object.entries(item).forEach(([key, value]) => {
              const exists = mergedAttributes[key];
              if (!exists) {
                  mergedAttributes[key] = value;
                  return;
              }
              if (key === 'class') {
                  mergedAttributes[key] = [mergedAttributes[key], value].join(' ');
              }
              else if (key === 'style') {
                  mergedAttributes[key] = [mergedAttributes[key], value].join('; ');
              }
              else {
                  mergedAttributes[key] = value;
              }
          });
          return mergedAttributes;
      }, {});
  }

  function getRenderedAttributes(nodeOrMark, extensionAttributes) {
      return extensionAttributes
          .filter(item => item.attribute.rendered)
          .map(item => {
          if (!item.attribute.renderHTML) {
              return {
                  [item.name]: nodeOrMark.attrs[item.name],
              };
          }
          return item.attribute.renderHTML(nodeOrMark.attrs) || {};
      })
          .reduce((attributes, attribute) => {
          return mergeAttributes(attributes, attribute);
      }, {});
  }

  function isEmptyObject(object = {}) {
      return Object.keys(object).length === 0 && object.constructor === Object;
  }

  function fromString(value) {
      if (typeof value !== 'string') {
          return value;
      }
      if (value.match(/^\d*(\.\d+)?$/)) {
          return Number(value);
      }
      if (value === 'true') {
          return true;
      }
      if (value === 'false') {
          return false;
      }
      return value;
  }

  /**
   * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).
   * Cancels when `getAttrs` returned `false`.
   * @param parseRule ProseMirror ParseRule
   * @param extensionAttributes List of attributes to inject
   */
  function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
      if (parseRule.style) {
          return parseRule;
      }
      return {
          ...parseRule,
          getAttrs: node => {
              const oldAttributes = parseRule.getAttrs
                  ? parseRule.getAttrs(node)
                  : parseRule.attrs;
              if (oldAttributes === false) {
                  return false;
              }
              const newAttributes = extensionAttributes
                  .filter(item => item.attribute.rendered)
                  .reduce((items, item) => {
                  const attributes = item.attribute.parseHTML
                      ? item.attribute.parseHTML(node) || {}
                      : {
                          [item.name]: fromString(node.getAttribute(item.name)),
                      };
                  const filteredAttributes = Object.fromEntries(Object.entries(attributes)
                      .filter(([, value]) => value !== undefined && value !== null));
                  return {
                      ...items,
                      ...filteredAttributes,
                  };
              }, {});
              return { ...oldAttributes, ...newAttributes };
          },
      };
  }

  /**
   * Optionally calls `value` as a function.
   * Otherwise it is returned directly.
   * @param value Function or any value.
   * @param context Optional context to bind to function.
   * @param props Optional props to pass to function.
   */
  function callOrReturn(value, context = undefined, ...props) {
      if (typeof value === 'function') {
          if (context) {
              return value.bind(context)(...props);
          }
          return value(...props);
      }
      return value;
  }

  function cleanUpSchemaItem(data) {
      return Object.fromEntries(Object.entries(data).filter(([key, value]) => {
          if (key === 'attrs' && isEmptyObject(value)) {
              return false;
          }
          return value !== null && value !== undefined;
      }));
  }
  function getSchemaByResolvedExtensions(extensions) {
      var _a;
      const allAttributes = getAttributesFromExtensions(extensions);
      const { nodeExtensions, markExtensions } = splitExtensions(extensions);
      const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;
      const nodes = Object.fromEntries(nodeExtensions.map(extension => {
          const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);
          const context = {
              name: extension.name,
              options: extension.options,
          };
          const extraNodeFields = extensions.reduce((fields, e) => {
              const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);
              return {
                  ...fields,
                  ...(extendNodeSchema ? extendNodeSchema(extension) : {}),
              };
          }, {});
          const schema = cleanUpSchemaItem({
              ...extraNodeFields,
              content: callOrReturn(getExtensionField(extension, 'content', context)),
              marks: callOrReturn(getExtensionField(extension, 'marks', context)),
              group: callOrReturn(getExtensionField(extension, 'group', context)),
              inline: callOrReturn(getExtensionField(extension, 'inline', context)),
              atom: callOrReturn(getExtensionField(extension, 'atom', context)),
              selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),
              draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),
              code: callOrReturn(getExtensionField(extension, 'code', context)),
              defining: callOrReturn(getExtensionField(extension, 'defining', context)),
              isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),
              attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {
                  var _a;
                  return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];
              })),
          });
          const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));
          if (parseHTML) {
              schema.parseDOM = parseHTML
                  .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
          }
          const renderHTML = getExtensionField(extension, 'renderHTML', context);
          if (renderHTML) {
              schema.toDOM = node => renderHTML({
                  node,
                  HTMLAttributes: getRenderedAttributes(node, extensionAttributes),
              });
          }
          return [extension.name, schema];
      }));
      const marks = Object.fromEntries(markExtensions.map(extension => {
          const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);
          const context = {
              name: extension.name,
              options: extension.options,
          };
          const extraMarkFields = extensions.reduce((fields, e) => {
              const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);
              return {
                  ...fields,
                  ...(extendMarkSchema ? extendMarkSchema(extension) : {}),
              };
          }, {});
          const schema = cleanUpSchemaItem({
              ...extraMarkFields,
              inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),
              excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),
              group: callOrReturn(getExtensionField(extension, 'group', context)),
              spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),
              attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {
                  var _a;
                  return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];
              })),
          });
          const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));
          if (parseHTML) {
              schema.parseDOM = parseHTML
                  .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
          }
          const renderHTML = getExtensionField(extension, 'renderHTML', context);
          if (renderHTML) {
              schema.toDOM = mark => renderHTML({
                  mark,
                  HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),
              });
          }
          return [extension.name, schema];
      }));
      return new prosemirrorModel.Schema({
          topNode,
          nodes,
          marks,
      });
  }

  function getSchemaTypeByName(name, schema) {
      if (schema.nodes[name]) {
          return schema.nodes[name];
      }
      if (schema.marks[name]) {
          return schema.marks[name];
      }
      return null;
  }

  class ExtensionManager {
      constructor(extensions, editor) {
          this.splittableMarks = [];
          this.editor = editor;
          this.extensions = ExtensionManager.resolve(extensions);
          this.schema = getSchemaByResolvedExtensions(this.extensions);
          this.extensions.forEach(extension => {
              var _a;
              const context = {
                  name: extension.name,
                  options: extension.options,
                  editor: this.editor,
                  type: getSchemaTypeByName(extension.name, this.schema),
              };
              if (extension.type === 'mark') {
                  const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;
                  if (keepOnSplit) {
                      this.splittableMarks.push(extension.name);
                  }
              }
              const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);
              if (onBeforeCreate) {
                  this.editor.on('beforeCreate', onBeforeCreate);
              }
              const onCreate = getExtensionField(extension, 'onCreate', context);
              if (onCreate) {
                  this.editor.on('create', onCreate);
              }
              const onUpdate = getExtensionField(extension, 'onUpdate', context);
              if (onUpdate) {
                  this.editor.on('update', onUpdate);
              }
              const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);
              if (onSelectionUpdate) {
                  this.editor.on('selectionUpdate', onSelectionUpdate);
              }
              const onTransaction = getExtensionField(extension, 'onTransaction', context);
              if (onTransaction) {
                  this.editor.on('transaction', onTransaction);
              }
              const onFocus = getExtensionField(extension, 'onFocus', context);
              if (onFocus) {
                  this.editor.on('focus', onFocus);
              }
              const onBlur = getExtensionField(extension, 'onBlur', context);
              if (onBlur) {
                  this.editor.on('blur', onBlur);
              }
              const onDestroy = getExtensionField(extension, 'onDestroy', context);
              if (onDestroy) {
                  this.editor.on('destroy', onDestroy);
              }
          });
      }
      static resolve(extensions) {
          return ExtensionManager.sort(ExtensionManager.flatten(extensions));
      }
      static flatten(extensions) {
          return extensions
              .map(extension => {
              const context = {
                  name: extension.name,
                  options: extension.options,
              };
              const addExtensions = getExtensionField(extension, 'addExtensions', context);
              if (addExtensions) {
                  return [
                      extension,
                      ...this.flatten(addExtensions()),
                  ];
              }
              return extension;
          })
              // `Infinity` will break TypeScript so we set a number that is probably high enough
              .flat(10);
      }
      static sort(extensions) {
          const defaultPriority = 100;
          return extensions.sort((a, b) => {
              const priorityA = getExtensionField(a, 'priority') || defaultPriority;
              const priorityB = getExtensionField(b, 'priority') || defaultPriority;
              if (priorityA > priorityB) {
                  return -1;
              }
              if (priorityA < priorityB) {
                  return 1;
              }
              return 0;
          });
      }
      get commands() {
          return this.extensions.reduce((commands, extension) => {
              const context = {
                  name: extension.name,
                  options: extension.options,
                  editor: this.editor,
                  type: getSchemaTypeByName(extension.name, this.schema),
              };
              const addCommands = getExtensionField(extension, 'addCommands', context);
              if (!addCommands) {
                  return commands;
              }
              return {
                  ...commands,
                  ...addCommands(),
              };
          }, {});
      }
      get plugins() {
          return [...this.extensions]
              .reverse()
              .map(extension => {
              const context = {
                  name: extension.name,
                  options: extension.options,
                  editor: this.editor,
                  type: getSchemaTypeByName(extension.name, this.schema),
              };
              const plugins = [];
              const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);
              if (addKeyboardShortcuts) {
                  const bindings = Object.fromEntries(Object
                      .entries(addKeyboardShortcuts())
                      .map(([shortcut, method]) => {
                      return [shortcut, () => method({ editor: this.editor })];
                  }));
                  const keyMapPlugin = prosemirrorKeymap.keymap(bindings);
                  plugins.push(keyMapPlugin);
              }
              const addInputRules = getExtensionField(extension, 'addInputRules', context);
              if (this.editor.options.enableInputRules && addInputRules) {
                  const inputRules = addInputRules();
                  const inputRulePlugins = inputRules.length
                      ? [prosemirrorInputrules.inputRules({ rules: inputRules })]
                      : [];
                  plugins.push(...inputRulePlugins);
              }
              const addPasteRules = getExtensionField(extension, 'addPasteRules', context);
              if (this.editor.options.enablePasteRules && addPasteRules) {
                  const pasteRulePlugins = addPasteRules();
                  plugins.push(...pasteRulePlugins);
              }
              const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);
              if (addProseMirrorPlugins) {
                  const proseMirrorPlugins = addProseMirrorPlugins();
                  plugins.push(...proseMirrorPlugins);
              }
              return plugins;
          })
              .flat();
      }
      get attributes() {
          return getAttributesFromExtensions(this.extensions);
      }
      get nodeViews() {
          const { editor } = this;
          const { nodeExtensions } = splitExtensions(this.extensions);
          return Object.fromEntries(nodeExtensions
              .filter(extension => !!getExtensionField(extension, 'addNodeView'))
              .map(extension => {
              const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);
              const context = {
                  name: extension.name,
                  options: extension.options,
                  editor,
                  type: getNodeType(extension.name, this.schema),
              };
              const addNodeView = getExtensionField(extension, 'addNodeView', context);
              if (!addNodeView) {
                  return [];
              }
              const nodeview = (node, view, getPos, decorations) => {
                  const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
                  return addNodeView()({
                      editor,
                      node,
                      getPos,
                      decorations,
                      HTMLAttributes,
                      extension,
                  });
              };
              return [extension.name, nodeview];
          }));
      }
      get textSerializers() {
          const { editor } = this;
          const { nodeExtensions } = splitExtensions(this.extensions);
          return Object.fromEntries(nodeExtensions
              .filter(extension => !!getExtensionField(extension, 'renderText'))
              .map(extension => {
              const context = {
                  name: extension.name,
                  options: extension.options,
                  editor,
                  type: getNodeType(extension.name, this.schema),
              };
              const renderText = getExtensionField(extension, 'renderText', context);
              if (!renderText) {
                  return [];
              }
              const textSerializer = (props) => renderText(props);
              return [extension.name, textSerializer];
          }));
      }
  }

  class EventEmitter {
      constructor() {
          this.callbacks = {};
      }
      on(event, fn) {
          if (!this.callbacks[event]) {
              this.callbacks[event] = [];
          }
          this.callbacks[event].push(fn);
          return this;
      }
      emit(event, ...args) {
          const callbacks = this.callbacks[event];
          if (callbacks) {
              callbacks.forEach(callback => callback.apply(this, args));
          }
          return this;
      }
      off(event, fn) {
          const callbacks = this.callbacks[event];
          if (callbacks) {
              if (fn) {
                  this.callbacks[event] = callbacks.filter(callback => callback !== fn);
              }
              else {
                  delete this.callbacks[event];
              }
          }
          return this;
      }
      removeAllListeners() {
          this.callbacks = {};
      }
  }

  // see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts
  function getType(payload) {
      return Object.prototype.toString.call(payload).slice(8, -1);
  }
  function isPlainObject(payload) {
      if (getType(payload) !== 'Object')
          return false;
      return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
  }

  function mergeDeep(target, source) {
      const output = { ...target };
      if (isPlainObject(target) && isPlainObject(source)) {
          Object.keys(source).forEach(key => {
              if (isPlainObject(source[key])) {
                  if (!(key in target)) {
                      Object.assign(output, { [key]: source[key] });
                  }
                  else {
                      output[key] = mergeDeep(target[key], source[key]);
                  }
              }
              else {
                  Object.assign(output, { [key]: source[key] });
              }
          });
      }
      return output;
  }

  class Extension {
      constructor(config = {}) {
          this.type = 'extension';
          this.name = 'extension';
          this.parent = null;
          this.child = null;
          this.config = {
              name: this.name,
              defaultOptions: {},
          };
          this.config = {
              ...this.config,
              ...config,
          };
          this.name = this.config.name;
          this.options = this.config.defaultOptions;
      }
      static create(config = {}) {
          return new Extension(config);
      }
      configure(options = {}) {
          // return a new instance so we can use the same extension
          // with different calls of `configure`
          const extension = this.extend();
          extension.options = mergeDeep(this.options, options);
          return extension;
      }
      extend(extendedConfig = {}) {
          const extension = new Extension(extendedConfig);
          extension.parent = this;
          this.child = extension;
          extension.name = extendedConfig.name
              ? extendedConfig.name
              : extension.parent.name;
          extension.options = extendedConfig.defaultOptions
              ? extendedConfig.defaultOptions
              : extension.parent.options;
          return extension;
      }
  }

  const textBetween = (editor, from, to, blockSeparator, leafText) => {
      let text = '';
      let separated = true;
      editor.state.doc.nodesBetween(from, to, (node, pos) => {
          var _a;
          const textSerializer = editor.extensionManager.textSerializers[node.type.name];
          if (textSerializer) {
              text += textSerializer({ node });
              separated = !blockSeparator;
          }
          else if (node.isText) {
              text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);
              separated = !blockSeparator;
          }
          else if (node.isLeaf && leafText) {
              text += leafText;
              separated = !blockSeparator;
          }
          else if (!separated && node.isBlock) {
              text += blockSeparator;
              separated = true;
          }
      }, 0);
      return text;
  };
  const ClipboardTextSerializer = Extension.create({
      name: 'editable',
      addProseMirrorPlugins() {
          return [
              new prosemirrorState.Plugin({
                  key: new prosemirrorState.PluginKey('clipboardTextSerializer'),
                  props: {
                      clipboardTextSerializer: () => {
                          const { editor } = this;
                          const { from, to } = editor.state.selection;
                          return textBetween(editor, from, to, '\n');
                      },
                  },
              }),
          ];
      },
  });

  const blur = () => ({ view }) => {
      const element = view.dom;
      element.blur();
      return true;
  };

  var blur$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    blur: blur
  });

  const clearContent = (emitUpdate = false) => ({ commands }) => {
      return commands.setContent('', emitUpdate);
  };

  var clearContent$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    clearContent: clearContent
  });

  const clearNodes = () => ({ state, tr, dispatch }) => {
      const { selection } = tr;
      const { ranges } = selection;
      ranges.forEach(range => {
          state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
              if (node.type.isText) {
                  return;
              }
              const $fromPos = tr.doc.resolve(tr.mapping.map(pos));
              const $toPos = tr.doc.resolve(tr.mapping.map(pos + node.nodeSize));
              const nodeRange = $fromPos.blockRange($toPos);
              if (!nodeRange) {
                  return;
              }
              const targetLiftDepth = prosemirrorTransform.liftTarget(nodeRange);
              if (node.type.isTextblock && dispatch) {
                  const { defaultType } = $fromPos.parent.contentMatchAt($fromPos.index());
                  tr.setNodeMarkup(nodeRange.start, defaultType);
              }
              if ((targetLiftDepth || targetLiftDepth === 0) && dispatch) {
                  tr.lift(nodeRange, targetLiftDepth);
              }
          });
      });
      return true;
  };

  var clearNodes$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    clearNodes: clearNodes
  });

  const command = fn => props => {
      return fn(props);
  };

  var command$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    command: command
  });

  const createParagraphNear = () => ({ state, dispatch }) => {
      return prosemirrorCommands.createParagraphNear(state, dispatch);
  };

  var createParagraphNear$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createParagraphNear: createParagraphNear
  });

  const deleteRange = range => ({ tr, dispatch }) => {
      const { from, to } = range;
      if (dispatch) {
          tr.delete(from, to);
      }
      return true;
  };

  var deleteRange$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    deleteRange: deleteRange
  });

  const deleteSelection = () => ({ state, dispatch }) => {
      return prosemirrorCommands.deleteSelection(state, dispatch);
  };

  var deleteSelection$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    deleteSelection: deleteSelection
  });

  const enter = () => ({ commands }) => {
      return commands.keyboardShortcut('Enter');
  };

  var enter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    enter: enter
  });

  const exitCode = () => ({ state, dispatch }) => {
      return prosemirrorCommands.exitCode(state, dispatch);
  };

  var exitCode$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    exitCode: exitCode
  });

  function findMarkInSet(marks, type, attributes = {}) {
      return marks.find(item => {
          return item.type === type && objectIncludes(item.attrs, attributes);
      });
  }
  function isMarkInSet(marks, type, attributes = {}) {
      return !!findMarkInSet(marks, type, attributes);
  }
  function getMarkRange($pos, type, attributes = {}) {
      if (!$pos || !type) {
          return;
      }
      const start = $pos.parent.childAfter($pos.parentOffset);
      if (!start.node) {
          return;
      }
      const mark = findMarkInSet(start.node.marks, type, attributes);
      if (!mark) {
          return;
      }
      let startIndex = $pos.index();
      let startPos = $pos.start() + start.offset;
      let endIndex = startIndex + 1;
      let endPos = startPos + start.node.nodeSize;
      findMarkInSet(start.node.marks, type, attributes);
      while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
          startIndex -= 1;
          startPos -= $pos.parent.child(startIndex).nodeSize;
      }
      while (endIndex < $pos.parent.childCount
          && isMarkInSet($pos.parent.child(endIndex).marks, type, attributes)) {
          endPos += $pos.parent.child(endIndex).nodeSize;
          endIndex += 1;
      }
      return {
          from: startPos,
          to: endPos,
      };
  }

  const extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      const type = getMarkType(typeOrName, state.schema);
      const { doc, selection } = tr;
      const { $from, from, to } = selection;
      if (dispatch) {
          const range = getMarkRange($from, type, attributes);
          if (range && range.from <= from && range.to >= to) {
              const newSelection = prosemirrorState.TextSelection.create(doc, range.from, range.to);
              tr.setSelection(newSelection);
          }
      }
      return true;
  };

  var extendMarkRange$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    extendMarkRange: extendMarkRange
  });

  const first = commands => props => {
      const items = typeof commands === 'function'
          ? commands(props)
          : commands;
      for (let i = 0; i < items.length; i += 1) {
          if (items[i](props)) {
              return true;
          }
      }
      return false;
  };

  var first$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    first: first
  });

  function minMax(value = 0, min = 0, max = 0) {
      return Math.min(Math.max(value, min), max);
  }

  function isClass(item) {
      var _a;
      if (((_a = item.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== 'class') {
          return false;
      }
      return true;
  }

  function isObject(item) {
      return (item
          && typeof item === 'object'
          && !Array.isArray(item)
          && !isClass(item));
  }

  function isTextSelection(value) {
      return isObject(value) && value instanceof prosemirrorState.TextSelection;
  }

  function resolveSelection(state, position = null) {
      if (!position) {
          return null;
      }
      if (position === 'start' || position === true) {
          return {
              from: 0,
              to: 0,
          };
      }
      if (position === 'end') {
          const { size } = state.doc.content;
          return {
              from: size,
              to: size,
          };
      }
      return {
          from: position,
          to: position,
      };
  }
  const focus = (position = null) => ({ editor, view, tr, dispatch, }) => {
      if ((view.hasFocus() && position === null) || position === false) {
          return true;
      }
      // we donâ€™t try to resolve a NodeSelection or CellSelection
      if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
          view.focus();
          return true;
      }
      const { from, to } = resolveSelection(editor.state, position) || editor.state.selection;
      const { doc, storedMarks } = tr;
      const resolvedFrom = minMax(from, 0, doc.content.size);
      const resolvedEnd = minMax(to, 0, doc.content.size);
      const selection = prosemirrorState.TextSelection.create(doc, resolvedFrom, resolvedEnd);
      const isSameSelection = editor.state.selection.eq(selection);
      if (dispatch) {
          tr.setSelection(selection);
          // `tr.setSelection` resets the stored marks
          // so weâ€™ll restore them if the selection is the same as before
          if (isSameSelection && storedMarks) {
              tr.setStoredMarks(storedMarks);
          }
          view.focus();
      }
      return true;
  };

  var focus$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    focus: focus
  });

  const insertContent = value => ({ tr, commands }) => {
      return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value);
  };

  var insertContent$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    insertContent: insertContent
  });

  // source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466
  function selectionToInsertionEnd(tr, startLen, bias) {
      const last = tr.steps.length - 1;
      if (last < startLen) {
          return;
      }
      const step = tr.steps[last];
      if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep)) {
          return;
      }
      const map = tr.mapping.maps[last];
      let end = 0;
      map.forEach((_from, _to, _newFrom, newTo) => {
          if (end === 0) {
              end = newTo;
          }
      });
      tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(end), bias));
  }

  const insertContentAt = (position, value) => ({ tr, dispatch, editor }) => {
      if (dispatch) {
          const content = createNodeFromContent(value, editor.schema, {
              parseOptions: {
                  preserveWhitespace: 'full',
              },
          });
          // donâ€™t dispatch an empty fragment because this can lead to strange errors
          if (content.toString() === '<>') {
              return true;
          }
          const { from, to } = typeof position === 'number'
              ? { from: position, to: position }
              : position;
          tr.replaceWith(from, to, content);
          // set cursor at end of inserted content
          selectionToInsertionEnd(tr, tr.steps.length - 1, 1);
      }
      return true;
  };

  var insertContentAt$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    insertContentAt: insertContentAt
  });

  const joinBackward = () => ({ state, dispatch }) => {
      return prosemirrorCommands.joinBackward(state, dispatch);
  };

  var joinBackward$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    joinBackward: joinBackward
  });

  const joinForward = () => ({ state, dispatch }) => {
      return prosemirrorCommands.joinForward(state, dispatch);
  };

  var joinForward$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    joinForward: joinForward
  });

  const mac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
  function normalizeKeyName(name) {
      const parts = name.split(/-(?!$)/);
      let result = parts[parts.length - 1];
      if (result === 'Space') {
          result = ' ';
      }
      let alt;
      let ctrl;
      let shift;
      let meta;
      for (let i = 0; i < parts.length - 1; i += 1) {
          const mod = parts[i];
          if (/^(cmd|meta|m)$/i.test(mod)) {
              meta = true;
          }
          else if (/^a(lt)?$/i.test(mod)) {
              alt = true;
          }
          else if (/^(c|ctrl|control)$/i.test(mod)) {
              ctrl = true;
          }
          else if (/^s(hift)?$/i.test(mod)) {
              shift = true;
          }
          else if (/^mod$/i.test(mod)) {
              if (mac) {
                  meta = true;
              }
              else {
                  ctrl = true;
              }
          }
          else {
              throw new Error(`Unrecognized modifier name: ${mod}`);
          }
      }
      if (alt) {
          result = `Alt-${result}`;
      }
      if (ctrl) {
          result = `Ctrl-${result}`;
      }
      if (meta) {
          result = `Meta-${result}`;
      }
      if (shift) {
          result = `Shift-${result}`;
      }
      return result;
  }
  const keyboardShortcut = name => ({ editor, view, tr, dispatch, }) => {
      const keys = normalizeKeyName(name).split(/-(?!$)/);
      const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));
      const event = new KeyboardEvent('keydown', {
          key: key === 'Space'
              ? ' '
              : key,
          altKey: keys.includes('Alt'),
          ctrlKey: keys.includes('Ctrl'),
          metaKey: keys.includes('Meta'),
          shiftKey: keys.includes('Shift'),
          bubbles: true,
          cancelable: true,
      });
      const capturedTransaction = editor.captureTransaction(() => {
          view.someProp('handleKeyDown', f => f(view, event));
      });
      capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {
          const newStep = step.map(tr.mapping);
          if (newStep && dispatch) {
              tr.maybeStep(newStep);
          }
      });
      return true;
  };

  var keyboardShortcut$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    keyboardShortcut: keyboardShortcut
  });

  const lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (!isActive) {
          return false;
      }
      return prosemirrorCommands.lift(state, dispatch);
  };

  var lift$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    lift: lift
  });

  const liftEmptyBlock = () => ({ state, dispatch }) => {
      return prosemirrorCommands.liftEmptyBlock(state, dispatch);
  };

  var liftEmptyBlock$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    liftEmptyBlock: liftEmptyBlock
  });

  const liftListItem = typeOrName => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return prosemirrorSchemaList.liftListItem(type)(state, dispatch);
  };

  var liftListItem$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    liftListItem: liftListItem
  });

  const newlineInCode = () => ({ state, dispatch }) => {
      return prosemirrorCommands.newlineInCode(state, dispatch);
  };

  var newlineInCode$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    newlineInCode: newlineInCode
  });

  const replace = (typeOrName, attributes = {}) => ({ state, commands }) => {
      console.warn('[tiptap warn]: replace() is deprecated. please use insertContent() instead.');
      const { from, to } = state.selection;
      const range = { from, to };
      return commands.replaceRange(range, typeOrName, attributes);
  };

  var replace$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    replace: replace
  });

  const replaceRange = (range, typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      console.warn('[tiptap warn]: replaceRange() is deprecated. please use insertContent() instead.');
      const type = getNodeType(typeOrName, state.schema);
      const { from, to } = range;
      // const $from = tr.doc.resolve(from)
      // const index = $from.index()
      // if (!$from.parent.canReplaceWith(index, index, type)) {
      //   return false
      // }
      if (dispatch) {
          tr.replaceRangeWith(from, to, type.create(attributes));
      }
      return true;
  };

  var replaceRange$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    replaceRange: replaceRange
  });

  /**
   * Remove a property or an array of properties from an object
   * @param obj Object
   * @param key Key to remove
   */
  function deleteProps(obj, propOrProps) {
      const props = typeof propOrProps === 'string'
          ? [propOrProps]
          : propOrProps;
      return Object
          .keys(obj)
          .reduce((newObj, prop) => {
          if (!props.includes(prop)) {
              newObj[prop] = obj[prop];
          }
          return newObj;
      }, {});
  }

  const resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'
          ? typeOrName
          : typeOrName.name, state.schema);
      if (!schemaType) {
          return false;
      }
      if (schemaType === 'node') {
          nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === 'mark') {
          markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
          tr.selection.ranges.forEach(range => {
              state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
                  if (nodeType && nodeType === node.type) {
                      tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));
                  }
                  if (markType && node.marks.length) {
                      node.marks.forEach(mark => {
                          if (markType === mark.type) {
                              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
                          }
                      });
                  }
              });
          });
      }
      return true;
  };

  var resetAttributes$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    resetAttributes: resetAttributes
  });

  const scrollIntoView = () => ({ tr, dispatch }) => {
      if (dispatch) {
          tr.scrollIntoView();
      }
      return true;
  };

  var scrollIntoView$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    scrollIntoView: scrollIntoView
  });

  const selectAll = () => ({ state, dispatch }) => {
      return prosemirrorCommands.selectAll(state, dispatch);
  };

  var selectAll$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    selectAll: selectAll
  });

  const selectNodeBackward = () => ({ state, dispatch }) => {
      return prosemirrorCommands.selectNodeBackward(state, dispatch);
  };

  var selectNodeBackward$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    selectNodeBackward: selectNodeBackward
  });

  const selectNodeForward = () => ({ state, dispatch }) => {
      return prosemirrorCommands.selectNodeForward(state, dispatch);
  };

  var selectNodeForward$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    selectNodeForward: selectNodeForward
  });

  const selectParentNode = () => ({ state, dispatch }) => {
      return prosemirrorCommands.selectParentNode(state, dispatch);
  };

  var selectParentNode$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    selectParentNode: selectParentNode
  });

  const setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {
      const { doc } = tr;
      const document = createDocument(content, editor.schema, parseOptions);
      const selection = prosemirrorState.TextSelection.create(doc, 0, doc.content.size);
      if (dispatch) {
          tr.setSelection(selection)
              .replaceSelectionWith(document, false)
              .setMeta('preventUpdate', !emitUpdate);
      }
      return true;
  };

  var setContent$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setContent: setContent
  });

  const setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      const { selection } = tr;
      const { empty, ranges } = selection;
      const type = getMarkType(typeOrName, state.schema);
      if (dispatch) {
          if (empty) {
              const oldAttributes = getMarkAttributes(state, type);
              tr.addStoredMark(type.create({
                  ...oldAttributes,
                  ...attributes,
              }));
          }
          else {
              ranges.forEach(range => {
                  const from = range.$from.pos;
                  const to = range.$to.pos;
                  state.doc.nodesBetween(from, to, (node, pos) => {
                      const trimmedFrom = Math.max(pos, from);
                      const trimmedTo = Math.min(pos + node.nodeSize, to);
                      const someHasMark = node.marks.find(mark => mark.type === type);
                      // if there is already a mark of this type
                      // we know that we have to merge its attributes
                      // otherwise we add a fresh new mark
                      if (someHasMark) {
                          node.marks.forEach(mark => {
                              if (type === mark.type) {
                                  tr.addMark(trimmedFrom, trimmedTo, type.create({
                                      ...mark.attrs,
                                      ...attributes,
                                  }));
                              }
                          });
                      }
                      else {
                          tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
                      }
                  });
              });
          }
      }
      return true;
  };

  var setMark$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setMark: setMark
  });

  const setMeta = (key, value) => ({ tr }) => {
      tr.setMeta(key, value);
      return true;
  };

  var setMeta$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setMeta: setMeta
  });

  const setNode = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return prosemirrorCommands.setBlockType(type, attributes)(state, dispatch);
  };

  var setNode$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setNode: setNode
  });

  const setNodeSelection = position => ({ tr, dispatch }) => {
      if (dispatch) {
          const { doc } = tr;
          const from = minMax(position, 0, doc.content.size);
          const selection = prosemirrorState.NodeSelection.create(doc, from);
          tr.setSelection(selection);
      }
      return true;
  };

  var setNodeSelection$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setNodeSelection: setNodeSelection
  });

  const setTextSelection = position => ({ tr, dispatch }) => {
      if (dispatch) {
          const { doc } = tr;
          const { from, to } = typeof position === 'number'
              ? { from: position, to: position }
              : position;
          const boundedFrom = minMax(from, 0, doc.content.size);
          const boundedTo = minMax(to, 0, doc.content.size);
          const selection = prosemirrorState.TextSelection.create(doc, boundedFrom, boundedTo);
          tr.setSelection(selection);
      }
      return true;
  };

  var setTextSelection$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setTextSelection: setTextSelection
  });

  const sinkListItem = typeOrName => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return prosemirrorSchemaList.sinkListItem(type)(state, dispatch);
  };

  var sinkListItem$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    sinkListItem: sinkListItem
  });

  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
      return Object.fromEntries(Object
          .entries(attributes)
          .filter(([name]) => {
          const extensionAttribute = extensionAttributes.find(item => {
              return item.type === typeName && item.name === name;
          });
          if (!extensionAttribute) {
              return false;
          }
          return extensionAttribute.attribute.keepOnSplit;
      }));
  }

  function defaultBlockAt(match) {
      for (let i = 0; i < match.edgeCount; i += 1) {
          const { type } = match.edge(i);
          if (type.isTextblock && !type.hasRequiredAttrs()) {
              return type;
          }
      }
      return null;
  }
  function ensureMarks(state, splittableMarks) {
      const marks = state.storedMarks
          || (state.selection.$to.parentOffset && state.selection.$from.marks());
      if (marks) {
          const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
          state.tr.ensureMarks(filteredMarks);
      }
  }
  const splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor, }) => {
      const { selection, doc } = tr;
      const { $from, $to } = selection;
      const extensionAttributes = editor.extensionManager.attributes;
      const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      if (selection instanceof prosemirrorState.NodeSelection && selection.node.isBlock) {
          if (!$from.parentOffset || !prosemirrorTransform.canSplit(doc, $from.pos)) {
              return false;
          }
          if (dispatch) {
              if (keepMarks) {
                  ensureMarks(state, editor.extensionManager.splittableMarks);
              }
              tr.split($from.pos).scrollIntoView();
          }
          return true;
      }
      if (!$from.parent.isBlock) {
          return false;
      }
      if (dispatch) {
          const atEnd = $to.parentOffset === $to.parent.content.size;
          if (selection instanceof prosemirrorState.TextSelection) {
              tr.deleteSelection();
          }
          const deflt = $from.depth === 0
              ? undefined
              : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
          let types = atEnd && deflt
              ? [{
                      type: deflt,
                      attrs: newAttributes,
                  }]
              : undefined;
          let can = prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
          if (!types
              && !can
              && prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {
              can = true;
              types = deflt
                  ? [{
                          type: deflt,
                          attrs: newAttributes,
                      }]
                  : undefined;
          }
          if (can) {
              tr.split(tr.mapping.map($from.pos), 1, types);
              if (deflt
                  && !atEnd
                  && !$from.parentOffset
                  && $from.parent.type !== deflt) {
                  const first = tr.mapping.map($from.before());
                  const $first = tr.doc.resolve(first);
                  if ($from.parent.canReplaceWith($first.index(), $first.index() + 1, deflt)) {
                      tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
                  }
              }
          }
          if (keepMarks) {
              ensureMarks(state, editor.extensionManager.splittableMarks);
          }
          tr.scrollIntoView();
      }
      return true;
  };

  var splitBlock$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    splitBlock: splitBlock
  });

  const splitListItem = typeOrName => ({ tr, state, dispatch, editor, }) => {
      var _a;
      const type = getNodeType(typeOrName, state.schema);
      const { $from, $to } = state.selection;
      // @ts-ignore
      // eslint-disable-next-line
      const node = state.selection.node;
      if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {
          return false;
      }
      const grandParent = $from.node(-1);
      if (grandParent.type !== type) {
          return false;
      }
      const extensionAttributes = editor.extensionManager.attributes;
      if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
          // In an empty block. If this is a nested list, the wrapping
          // list item should be split. Otherwise, bail out and let next
          // command handle lifting.
          if ($from.depth === 2
              || $from.node(-3).type !== type
              || $from.index(-2) !== $from.node(-2).childCount - 1) {
              return false;
          }
          if (dispatch) {
              let wrap = prosemirrorModel.Fragment.empty;
              const keepItem = $from.index(-1) > 0;
              // Build a fragment containing empty versions of the structure
              // from the outer list item to the parent node of the cursor
              for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d -= 1) {
                  wrap = prosemirrorModel.Fragment.from($from.node(d).copy(wrap));
              }
              // Add a second list item with an empty default start node
              const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
              const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;
              wrap = wrap.append(prosemirrorModel.Fragment.from(type.createAndFill(null, nextType) || undefined));
              tr
                  .replace($from.before(keepItem ? undefined : -1), $from.after(-3), new prosemirrorModel.Slice(wrap, keepItem ? 3 : 2, 2))
                  .setSelection(prosemirrorState.TextSelection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))))
                  .scrollIntoView();
          }
          return true;
      }
      const nextType = $to.pos === $from.end()
          ? grandParent.contentMatchAt(0).defaultType
          : null;
      const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      tr.delete($from.pos, $to.pos);
      const types = nextType
          ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }]
          : [{ type, attrs: newTypeAttributes }];
      if (!prosemirrorTransform.canSplit(tr.doc, $from.pos, 2)) {
          return false;
      }
      if (dispatch) {
          tr.split($from.pos, 2, types).scrollIntoView();
      }
      return true;
  };

  var splitListItem$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    splitListItem: splitListItem
  });

  function findParentNodeClosestToPos($pos, predicate) {
      for (let i = $pos.depth; i > 0; i -= 1) {
          const node = $pos.node(i);
          if (predicate(node)) {
              return {
                  pos: i > 0 ? $pos.before(i) : 0,
                  start: $pos.start(i),
                  depth: i,
                  node,
              };
          }
      }
  }

  function findParentNode(predicate) {
      return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
  }

  function isList(name, extensions) {
      const { nodeExtensions } = splitExtensions(extensions);
      const extension = nodeExtensions.find(item => item.name === name);
      if (!extension) {
          return false;
      }
      const context = {
          name: extension.name,
          options: extension.options,
      };
      const group = callOrReturn(getExtensionField(extension, 'group', context));
      if (typeof group !== 'string') {
          return false;
      }
      return group.split(' ').includes('list');
  }

  const toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch, chain, commands, can, }) => {
      const { extensions } = editor.extensionManager;
      const listType = getNodeType(listTypeOrName, state.schema);
      const itemType = getNodeType(itemTypeOrName, state.schema);
      const { selection } = state;
      const { $from, $to } = selection;
      const range = $from.blockRange($to);
      if (!range) {
          return false;
      }
      const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);
      if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
          // remove list
          if (parentList.node.type === listType) {
              return commands.liftListItem(itemType);
          }
          // change list type
          if (isList(parentList.node.type.name, extensions)
              && listType.validContent(parentList.node.content)
              && dispatch) {
              tr.setNodeMarkup(parentList.pos, listType);
              return true;
          }
      }
      const canWrapInList = can().wrapInList(listType);
      // try to convert node to paragraph if needed
      if (!canWrapInList) {
          return chain()
              .clearNodes()
              .wrapInList(listType)
              .run();
      }
      return commands.wrapInList(listType);
  };

  var toggleList$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toggleList: toggleList
  });

  const toggleMark = (typeOrName, attributes = {}) => ({ state, commands }) => {
      const type = getMarkType(typeOrName, state.schema);
      const isActive = isMarkActive(state, type, attributes);
      if (isActive) {
          return commands.unsetMark(type);
      }
      return commands.setMark(type, attributes);
  };

  var toggleMark$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toggleMark: toggleMark
  });

  const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
      const type = getNodeType(typeOrName, state.schema);
      const toggleType = getNodeType(toggleTypeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (isActive) {
          return commands.setNode(toggleType);
      }
      return commands.setNode(type, attributes);
  };

  var toggleNode$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toggleNode: toggleNode
  });

  const toggleWrap = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (isActive) {
          return prosemirrorCommands.lift(state, dispatch);
      }
      return prosemirrorCommands.wrapIn(type, attributes)(state, dispatch);
  };

  var toggleWrap$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toggleWrap: toggleWrap
  });

  const undoInputRule = () => ({ state, dispatch }) => {
      return prosemirrorInputrules.undoInputRule(state, dispatch);
  };

  var undoInputRule$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    undoInputRule: undoInputRule
  });

  const unsetAllMarks = () => ({ tr, state, dispatch }) => {
      const { selection } = tr;
      const { empty, ranges } = selection;
      if (empty) {
          return true;
      }
      if (dispatch) {
          Object
              .entries(state.schema.marks)
              .forEach(([, mark]) => {
              ranges.forEach(range => {
                  tr.removeMark(range.$from.pos, range.$to.pos, mark);
              });
          });
      }
      return true;
  };

  var unsetAllMarks$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    unsetAllMarks: unsetAllMarks
  });

  const unsetMark = typeOrName => ({ tr, state, dispatch }) => {
      const { selection } = tr;
      const type = getMarkType(typeOrName, state.schema);
      const { $from, empty, ranges } = selection;
      if (dispatch) {
          if (empty) {
              let { from, to } = selection;
              const range = getMarkRange($from, type);
              if (range) {
                  from = range.from;
                  to = range.to;
              }
              tr.removeMark(from, to, type);
          }
          else {
              ranges.forEach(range => {
                  tr.removeMark(range.$from.pos, range.$to.pos, type);
              });
          }
          tr.removeStoredMark(type);
      }
      return true;
  };

  var unsetMark$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    unsetMark: unsetMark
  });

  const updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'
          ? typeOrName
          : typeOrName.name, state.schema);
      if (!schemaType) {
          return false;
      }
      if (schemaType === 'node') {
          nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === 'mark') {
          markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
          tr.selection.ranges.forEach(range => {
              const from = range.$from.pos;
              const to = range.$to.pos;
              state.doc.nodesBetween(from, to, (node, pos) => {
                  if (nodeType && nodeType === node.type) {
                      tr.setNodeMarkup(pos, undefined, {
                          ...node.attrs,
                          ...attributes,
                      });
                  }
                  if (markType && node.marks.length) {
                      node.marks.forEach(mark => {
                          if (markType === mark.type) {
                              const trimmedFrom = Math.max(pos, from);
                              const trimmedTo = Math.min(pos + node.nodeSize, to);
                              tr.addMark(trimmedFrom, trimmedTo, markType.create({
                                  ...mark.attrs,
                                  ...attributes,
                              }));
                          }
                      });
                  }
              });
          });
      }
      return true;
  };

  var updateAttributes$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    updateAttributes: updateAttributes
  });

  const wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive = isNodeActive(state, type, attributes);
      if (isActive) {
          return false;
      }
      return prosemirrorCommands.wrapIn(type, attributes)(state, dispatch);
  };

  var wrapIn$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    wrapIn: wrapIn
  });

  const wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return prosemirrorSchemaList.wrapInList(type, attributes)(state, dispatch);
  };

  var wrapInList$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    wrapInList: wrapInList
  });

  const Commands = Extension.create({
      name: 'commands',
      addCommands() {
          return {
              ...blur$1,
              ...clearContent$1,
              ...clearNodes$1,
              ...command$1,
              ...createParagraphNear$1,
              ...deleteRange$1,
              ...deleteSelection$1,
              ...enter$1,
              ...exitCode$1,
              ...extendMarkRange$1,
              ...first$1,
              ...focus$1,
              ...insertContent$1,
              ...insertContentAt$1,
              ...joinBackward$1,
              ...joinForward$1,
              ...keyboardShortcut$1,
              ...lift$1,
              ...liftEmptyBlock$1,
              ...liftListItem$1,
              ...newlineInCode$1,
              ...replace$1,
              ...replaceRange$1,
              ...resetAttributes$1,
              ...scrollIntoView$1,
              ...selectAll$1,
              ...selectNodeBackward$1,
              ...selectNodeForward$1,
              ...selectParentNode$1,
              ...setContent$1,
              ...setMark$1,
              ...setMeta$1,
              ...setNode$1,
              ...setNodeSelection$1,
              ...setTextSelection$1,
              ...sinkListItem$1,
              ...splitBlock$1,
              ...splitListItem$1,
              ...toggleList$1,
              ...toggleMark$1,
              ...toggleNode$1,
              ...toggleWrap$1,
              ...undoInputRule$1,
              ...unsetAllMarks$1,
              ...unsetMark$1,
              ...updateAttributes$1,
              ...wrapIn$1,
              ...wrapInList$1,
          };
      },
  });

  const Editable = Extension.create({
      name: 'editable',
      addProseMirrorPlugins() {
          return [
              new prosemirrorState.Plugin({
                  key: new prosemirrorState.PluginKey('editable'),
                  props: {
                      editable: () => this.editor.options.editable,
                  },
              }),
          ];
      },
  });

  const FocusEvents = Extension.create({
      name: 'focusEvents',
      addProseMirrorPlugins() {
          const { editor } = this;
          return [
              new prosemirrorState.Plugin({
                  key: new prosemirrorState.PluginKey('focusEvents'),
                  props: {
                      attributes: {
                          tabindex: '0',
                      },
                      handleDOMEvents: {
                          focus: (view, event) => {
                              editor.isFocused = true;
                              const transaction = editor.state.tr
                                  .setMeta('focus', { event })
                                  .setMeta('addToHistory', false);
                              view.dispatch(transaction);
                              return false;
                          },
                          blur: (view, event) => {
                              editor.isFocused = false;
                              const transaction = editor.state.tr
                                  .setMeta('blur', { event })
                                  .setMeta('addToHistory', false);
                              view.dispatch(transaction);
                              return false;
                          },
                      },
                  },
              }),
          ];
      },
  });

  const Keymap = Extension.create({
      name: 'keymap',
      addKeyboardShortcuts() {
          const handleBackspace = () => this.editor.commands.first(({ commands }) => [
              () => commands.undoInputRule(),
              () => commands.deleteSelection(),
              () => commands.joinBackward(),
              () => commands.selectNodeBackward(),
          ]);
          const handleDelete = () => this.editor.commands.first(({ commands }) => [
              () => commands.deleteSelection(),
              () => commands.joinForward(),
              () => commands.selectNodeForward(),
          ]);
          return {
              Enter: () => this.editor.commands.first(({ commands }) => [
                  () => commands.newlineInCode(),
                  () => commands.createParagraphNear(),
                  () => commands.liftEmptyBlock(),
                  () => commands.splitBlock(),
              ]),
              'Mod-Enter': () => this.editor.commands.exitCode(),
              Backspace: () => handleBackspace(),
              'Mod-Backspace': () => handleBackspace(),
              Delete: () => handleDelete(),
              'Mod-Delete': () => handleDelete(),
              // we donâ€™t need a custom `selectAll` for now
              // 'Mod-a': () => this.editor.commands.selectAll(),
          };
      },
  });

  var extensions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ClipboardTextSerializer: ClipboardTextSerializer,
    Commands: Commands,
    Editable: Editable,
    FocusEvents: FocusEvents,
    Keymap: Keymap
  });

  const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;

  class Editor extends EventEmitter {
      constructor(options = {}) {
          super();
          this.isFocused = false;
          this.options = {
              element: document.createElement('div'),
              content: '',
              injectCSS: true,
              extensions: [],
              autofocus: false,
              editable: true,
              editorProps: {},
              parseOptions: {},
              enableInputRules: true,
              enablePasteRules: true,
              onBeforeCreate: () => null,
              onCreate: () => null,
              onUpdate: () => null,
              onSelectionUpdate: () => null,
              onTransaction: () => null,
              onFocus: () => null,
              onBlur: () => null,
              onDestroy: () => null,
          };
          this.isCapturingTransaction = false;
          this.capturedTransaction = null;
          this.setOptions(options);
          this.createExtensionManager();
          this.createCommandManager();
          this.createSchema();
          this.on('beforeCreate', this.options.onBeforeCreate);
          this.emit('beforeCreate', { editor: this });
          this.createView();
          this.injectCSS();
          this.on('create', this.options.onCreate);
          this.on('update', this.options.onUpdate);
          this.on('selectionUpdate', this.options.onSelectionUpdate);
          this.on('transaction', this.options.onTransaction);
          this.on('focus', this.options.onFocus);
          this.on('blur', this.options.onBlur);
          this.on('destroy', this.options.onDestroy);
          window.setTimeout(() => {
              if (this.isDestroyed) {
                  return;
              }
              this.commands.focus(this.options.autofocus);
              this.emit('create', { editor: this });
          }, 0);
      }
      /**
       * An object of all registered commands.
       */
      get commands() {
          return this.commandManager.createCommands();
      }
      /**
       * Create a command chain to call multiple commands at once.
       */
      chain() {
          return this.commandManager.createChain();
      }
      /**
       * Check if a command or a command chain can be executed. Without executing it.
       */
      can() {
          return this.commandManager.createCan();
      }
      /**
       * Inject CSS styles.
       */
      injectCSS() {
          if (this.options.injectCSS && document) {
              this.css = createStyleTag(style);
          }
      }
      /**
       * Update editor options.
       *
       * @param options A list of options
       */
      setOptions(options = {}) {
          this.options = { ...this.options, ...options };
      }
      /**
       * Update editable state of the editor.
       */
      setEditable(editable) {
          this.setOptions({ editable });
          if (this.view && this.state && !this.isDestroyed) {
              this.view.updateState(this.state);
          }
      }
      /**
       * Returns whether the editor is editable.
       */
      get isEditable() {
          return this.view && this.view.editable;
      }
      /**
       * Returns the editor state.
       */
      get state() {
          return this.view.state;
      }
      /**
       * Register a ProseMirror plugin.
       *
       * @param plugin A ProseMirror plugin
       * @param handlePlugins Control how to merge the plugin into the existing plugins.
       */
      registerPlugin(plugin, handlePlugins) {
          const plugins = typeof handlePlugins === 'function'
              ? handlePlugins(plugin, this.state.plugins)
              : [...this.state.plugins, plugin];
          const state = this.state.reconfigure({ plugins });
          this.view.updateState(state);
      }
      /**
       * Unregister a ProseMirror plugin.
       *
       * @param name The plugins name
       */
      unregisterPlugin(nameOrPluginKey) {
          if (this.isDestroyed) {
              return;
          }
          const name = typeof nameOrPluginKey === 'string'
              ? `${nameOrPluginKey}$`
              // @ts-ignore
              : nameOrPluginKey.key;
          const state = this.state.reconfigure({
              // @ts-ignore
              plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),
          });
          this.view.updateState(state);
      }
      /**
       * Creates an extension manager.
       */
      createExtensionManager() {
          const coreExtensions = Object.entries(extensions).map(([, extension]) => extension);
          const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {
              return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);
          });
          this.extensionManager = new ExtensionManager(allExtensions, this);
      }
      /**
       * Creates an command manager.
       */
      createCommandManager() {
          this.commandManager = new CommandManager(this, this.extensionManager.commands);
      }
      /**
       * Creates a ProseMirror schema.
       */
      createSchema() {
          this.schema = this.extensionManager.schema;
      }
      /**
       * Creates a ProseMirror view.
       */
      createView() {
          this.view = new prosemirrorView.EditorView(this.options.element, {
              ...this.options.editorProps,
              dispatchTransaction: this.dispatchTransaction.bind(this),
              state: prosemirrorState.EditorState.create({
                  doc: createDocument(this.options.content, this.schema, this.options.parseOptions),
              }),
          });
          // `editor.view` is not yet available at this time.
          // Therefore we will add all plugins and node views directly afterwards.
          const newState = this.state.reconfigure({
              plugins: this.extensionManager.plugins,
          });
          this.view.updateState(newState);
          this.createNodeViews();
          // Letâ€™s store the editor instance in the DOM element.
          // So weâ€™ll have access to it for tests.
          const dom = this.view.dom;
          dom.editor = this;
      }
      /**
       * Creates all node views.
       */
      createNodeViews() {
          this.view.setProps({
              nodeViews: this.extensionManager.nodeViews,
          });
      }
      captureTransaction(fn) {
          this.isCapturingTransaction = true;
          fn();
          this.isCapturingTransaction = false;
          const tr = this.capturedTransaction;
          this.capturedTransaction = null;
          return tr;
      }
      /**
       * The callback over which to send transactions (state updates) produced by the view.
       *
       * @param transaction An editor state transaction
       */
      dispatchTransaction(transaction) {
          if (this.isCapturingTransaction) {
              if (!this.capturedTransaction) {
                  this.capturedTransaction = transaction;
                  return;
              }
              transaction.steps.forEach(step => { var _a; return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step); });
              return;
          }
          const state = this.state.apply(transaction);
          const selectionHasChanged = !this.state.selection.eq(state.selection);
          this.view.updateState(state);
          this.emit('transaction', {
              editor: this,
              transaction,
          });
          if (selectionHasChanged) {
              this.emit('selectionUpdate', {
                  editor: this,
              });
          }
          const focus = transaction.getMeta('focus');
          const blur = transaction.getMeta('blur');
          if (focus) {
              this.emit('focus', {
                  editor: this,
                  event: focus.event,
              });
          }
          if (blur) {
              this.emit('blur', {
                  editor: this,
                  event: blur.event,
              });
          }
          if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {
              return;
          }
          this.emit('update', {
              editor: this,
              transaction,
          });
      }
      /**
       * Get attributes of the currently selected node or mark.
       */
      getAttributes(nameOrType) {
          return getAttributes(this.state, nameOrType);
      }
      /**
       * Get attributes of the currently selected node.
       *
       * @param name Name of the node
       */
      getNodeAttributes(name) {
          console.warn('[tiptap warn]: editor.getNodeAttributes() is deprecated. please use editor.getAttributes() instead.');
          return getNodeAttributes(this.state, name);
      }
      /**
       * Get attributes of the currently selected mark.
       *
       * @param name Name of the mark
       */
      getMarkAttributes(name) {
          console.warn('[tiptap warn]: editor.getMarkAttributes() is deprecated. please use editor.getAttributes() instead.');
          return getMarkAttributes(this.state, name);
      }
      isActive(nameOrAttributes, attributesOrUndefined) {
          const name = typeof nameOrAttributes === 'string'
              ? nameOrAttributes
              : null;
          const attributes = typeof nameOrAttributes === 'string'
              ? attributesOrUndefined
              : nameOrAttributes;
          return isActive(this.state, name, attributes);
      }
      /**
       * Get the document as JSON.
       */
      getJSON() {
          return this.state.doc.toJSON();
      }
      /**
       * Get the document as HTML.
       */
      getHTML() {
          return getHTMLFromFragment(this.state.doc, this.schema);
      }
      /**
       * Check if there is no content.
       */
      get isEmpty() {
          return isNodeEmpty(this.state.doc);
      }
      /**
       * Get the number of characters for the current document.
       */
      getCharacterCount() {
          return this.state.doc.content.size - 2;
      }
      /**
       * Destroy the editor.
       */
      destroy() {
          this.emit('destroy');
          if (this.view) {
              this.view.destroy();
          }
          this.removeAllListeners();
          removeElement(this.css);
      }
      /**
       * Check if the editor is already destroyed.
       */
      get isDestroyed() {
          var _a;
          // @ts-ignore
          return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
      }
  }

  class Node {
      constructor(config = {}) {
          this.type = 'node';
          this.name = 'node';
          this.parent = null;
          this.child = null;
          this.config = {
              name: this.name,
              defaultOptions: {},
          };
          this.config = {
              ...this.config,
              ...config,
          };
          this.name = this.config.name;
          this.options = this.config.defaultOptions;
      }
      static create(config = {}) {
          return new Node(config);
      }
      configure(options = {}) {
          // return a new instance so we can use the same extension
          // with different calls of `configure`
          const extension = this.extend();
          extension.options = mergeDeep(this.options, options);
          return extension;
      }
      extend(extendedConfig = {}) {
          const extension = new Node(extendedConfig);
          extension.parent = this;
          this.child = extension;
          extension.name = extendedConfig.name
              ? extendedConfig.name
              : extension.parent.name;
          extension.options = extendedConfig.defaultOptions
              ? extendedConfig.defaultOptions
              : extension.parent.options;
          return extension;
      }
  }

  class Mark {
      constructor(config = {}) {
          this.type = 'mark';
          this.name = 'mark';
          this.parent = null;
          this.child = null;
          this.config = {
              name: this.name,
              defaultOptions: {},
          };
          this.config = {
              ...this.config,
              ...config,
          };
          this.name = this.config.name;
          this.options = this.config.defaultOptions;
      }
      static create(config = {}) {
          return new Mark(config);
      }
      configure(options = {}) {
          // return a new instance so we can use the same extension
          // with different calls of `configure`
          const extension = this.extend();
          extension.options = mergeDeep(this.options, options);
          return extension;
      }
      extend(extendedConfig = {}) {
          const extension = new Mark(extendedConfig);
          extension.parent = this;
          this.child = extension;
          extension.name = extendedConfig.name
              ? extendedConfig.name
              : extension.parent.name;
          extension.options = extendedConfig.defaultOptions
              ? extendedConfig.defaultOptions
              : extension.parent.options;
          return extension;
      }
  }

  function isiOS() {
      return [
          'iPad Simulator',
          'iPhone Simulator',
          'iPod Simulator',
          'iPad',
          'iPhone',
          'iPod',
      ].includes(navigator.platform)
          // iPad on iOS 13 detection
          || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
  }

  class NodeView {
      constructor(component, props, options) {
          this.isDragging = false;
          this.options = {
              stopEvent: null,
              update: null,
          };
          this.component = component;
          this.options = { ...this.options, ...options };
          this.editor = props.editor;
          this.extension = props.extension;
          this.node = props.node;
          this.decorations = props.decorations;
          this.getPos = props.getPos;
          this.mount();
      }
      mount() {
          // eslint-disable-next-line
          return;
      }
      get dom() {
          return null;
      }
      get contentDOM() {
          return null;
      }
      onDragStart(event) {
          var _a, _b, _c;
          const { view } = this.editor;
          const target = event.target;
          // get the drag handle element
          // `closest` is not available for text nodes so we may have to use its parent
          const dragHandle = target.nodeType === 3
              ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]')
              : target.closest('[data-drag-handle]');
          if (!this.dom
              || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target))
              || !dragHandle) {
              return;
          }
          let x = 0;
          let y = 0;
          // calculate offset for drag element if we use a different drag handle element
          if (this.dom !== dragHandle) {
              const domBox = this.dom.getBoundingClientRect();
              const handleBox = dragHandle.getBoundingClientRect();
              x = handleBox.x - domBox.x + event.offsetX;
              y = handleBox.y - domBox.y + event.offsetY;
          }
          (_c = event.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(this.dom, x, y);
          // we need to tell ProseMirror that we want to move the whole node
          // so we create a NodeSelection
          const selection = prosemirrorState.NodeSelection.create(view.state.doc, this.getPos());
          const transaction = view.state.tr.setSelection(selection);
          view.dispatch(transaction);
      }
      stopEvent(event) {
          var _a;
          if (!this.dom) {
              return false;
          }
          if (typeof this.options.stopEvent === 'function') {
              return this.options.stopEvent(event);
          }
          const target = event.target;
          const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));
          // any event from child nodes should be handled by ProseMirror
          if (!isInElement) {
              return false;
          }
          const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName)
              || target.isContentEditable;
          // any input event within node views should be ignored by ProseMirror
          if (isInput) {
              return true;
          }
          const { isEditable } = this.editor;
          const { isDragging } = this;
          const isDraggable = !!this.node.type.spec.draggable;
          const isSelectable = prosemirrorState.NodeSelection.isSelectable(this.node);
          const isCopyEvent = event.type === 'copy';
          const isPasteEvent = event.type === 'paste';
          const isCutEvent = event.type === 'cut';
          const isClickEvent = event.type === 'mousedown';
          const isDragEvent = event.type.startsWith('drag') || event.type === 'drop';
          // ProseMirror tries to drag selectable nodes
          // even if `draggable` is set to `false`
          // this fix prevents that
          if (!isDraggable && isSelectable && isDragEvent) {
              event.preventDefault();
          }
          if (isDraggable && isDragEvent && !isDragging) {
              event.preventDefault();
              return false;
          }
          // we have to store that dragging started
          if (isDraggable && isEditable && !isDragging && isClickEvent) {
              const dragHandle = target.closest('[data-drag-handle]');
              const isValidDragHandle = dragHandle
                  && (this.dom === dragHandle || (this.dom.contains(dragHandle)));
              if (isValidDragHandle) {
                  this.isDragging = true;
                  document.addEventListener('dragend', () => {
                      this.isDragging = false;
                  }, { once: true });
                  document.addEventListener('mouseup', () => {
                      this.isDragging = false;
                  }, { once: true });
              }
          }
          // these events are handled by prosemirror
          if (isDragging
              || isCopyEvent
              || isPasteEvent
              || isCutEvent
              || (isClickEvent && isSelectable)) {
              return false;
          }
          return true;
      }
      ignoreMutation(mutation) {
          if (!this.dom || !this.contentDOM) {
              return true;
          }
          // a leaf/atom node is like a black box for ProseMirror
          // and should be fully handled by the node view
          if (this.node.isLeaf) {
              return true;
          }
          // ProseMirror should handle any selections
          if (mutation.type === 'selection') {
              return false;
          }
          // try to prevent a bug on iOS that will break node views on enter
          // this is because ProseMirror canâ€™t preventDispatch on enter
          // this will lead to a re-render of the node view on enter
          // see: https://github.com/ueberdosis/tiptap/issues/1214
          if (this.dom.contains(mutation.target) && mutation.type === 'childList' && isiOS()) {
              const changedNodes = [
                  ...Array.from(mutation.addedNodes),
                  ...Array.from(mutation.removedNodes),
              ];
              // weâ€™ll check if every changed node is contentEditable
              // to make sure itâ€™s probably mutated by ProseMirror
              if (changedNodes.every(node => node.isContentEditable)) {
                  return false;
              }
          }
          // we will allow mutation contentDOM with attributes
          // so we can for example adding classes within our node view
          if (this.contentDOM === mutation.target && mutation.type === 'attributes') {
              return true;
          }
          // ProseMirror should handle any changes within contentDOM
          if (this.contentDOM.contains(mutation.target)) {
              return false;
          }
          return true;
      }
      updateAttributes(attributes) {
          if (!this.editor.view.editable) {
              return;
          }
          const { state } = this.editor.view;
          const pos = this.getPos();
          const transaction = state.tr.setNodeMarkup(pos, undefined, {
              ...this.node.attrs,
              ...attributes,
          });
          this.editor.view.dispatch(transaction);
      }
      deleteNode() {
          const from = this.getPos();
          const to = from + this.node.nodeSize;
          this.editor.commands.deleteRange({ from, to });
      }
  }

  function nodeInputRule (regexp, type, getAttributes) {
      return new prosemirrorInputrules.InputRule(regexp, (state, match, start, end) => {
          const attributes = getAttributes instanceof Function
              ? getAttributes(match)
              : getAttributes;
          const { tr } = state;
          if (match[0]) {
              tr.replaceWith(start - 1, end, type.create(attributes));
          }
          return tr;
      });
  }

  function getMarksBetween(from, to, state) {
      let marks = [];
      state.doc.nodesBetween(from, to, (node, pos) => {
          marks = [...marks, ...node.marks.map(mark => ({
                  from: pos,
                  to: pos + node.nodeSize,
                  mark,
              }))];
      });
      return marks;
  }

  function markInputRule (regexp, markType, getAttributes) {
      return new prosemirrorInputrules.InputRule(regexp, (state, match, start, end) => {
          const attributes = getAttributes instanceof Function
              ? getAttributes(match)
              : getAttributes;
          const { tr } = state;
          const captureGroup = match[match.length - 1];
          const fullMatch = match[0];
          let markEnd = end;
          if (captureGroup) {
              const startSpaces = fullMatch.search(/\S/);
              const textStart = start + fullMatch.indexOf(captureGroup);
              const textEnd = textStart + captureGroup.length;
              const excludedMarks = getMarksBetween(start, end, state)
                  .filter(item => {
                  // TODO: PR to add excluded to MarkType
                  // @ts-ignore
                  const { excluded } = item.mark.type;
                  return excluded.find((type) => type.name === markType.name);
              })
                  .filter(item => item.to > textStart);
              if (excludedMarks.length) {
                  return null;
              }
              if (textEnd < end) {
                  tr.delete(textEnd, end);
              }
              if (textStart > start) {
                  tr.delete(start + startSpaces, textStart);
              }
              markEnd = start + startSpaces + captureGroup.length;
              tr.addMark(start + startSpaces, markEnd, markType.create(attributes));
              tr.removeStoredMark(markType);
          }
          return tr;
      });
  }

  function markPasteRule (regexp, type, getAttributes) {
      const handler = (fragment, parent) => {
          const nodes = [];
          fragment.forEach(child => {
              if (child.isText && child.text) {
                  const { text } = child;
                  let pos = 0;
                  let match;
                  // eslint-disable-next-line
                  while ((match = regexp.exec(text)) !== null) {
                      const outerMatch = Math.max(match.length - 2, 0);
                      const innerMatch = Math.max(match.length - 1, 0);
                      if (parent === null || parent === void 0 ? void 0 : parent.type.allowsMarkType(type)) {
                          const start = match.index;
                          const matchStart = start + match[0].indexOf(match[outerMatch]);
                          const matchEnd = matchStart + match[outerMatch].length;
                          const textStart = matchStart + match[outerMatch].lastIndexOf(match[innerMatch]);
                          const textEnd = textStart + match[innerMatch].length;
                          const attrs = getAttributes instanceof Function
                              ? getAttributes(match)
                              : getAttributes;
                          // adding text before markdown to nodes
                          if (matchStart > 0) {
                              nodes.push(child.cut(pos, matchStart));
                          }
                          // adding the markdown part to nodes
                          nodes.push(child
                              .cut(textStart, textEnd)
                              .mark(type.create(attrs).addToSet(child.marks)));
                          pos = matchEnd;
                      }
                  }
                  // adding rest of text to nodes
                  if (pos < text.length) {
                      nodes.push(child.cut(pos));
                  }
              }
              else {
                  nodes.push(child.copy(handler(child.content, child)));
              }
          });
          return prosemirrorModel.Fragment.fromArray(nodes);
      };
      return new prosemirrorState.Plugin({
          key: new prosemirrorState.PluginKey('markPasteRule'),
          props: {
              transformPasted: slice => {
                  return new prosemirrorModel.Slice(handler(slice.content), slice.openStart, slice.openEnd);
              },
          },
      });
  }

  function findChildren(node, predicate) {
      const nodesWithPos = [];
      node.descendants((child, pos) => {
          if (predicate(child)) {
              nodesWithPos.push({
                  node: child,
                  pos,
              });
          }
      });
      return nodesWithPos;
  }

  /**
   * Same as `findChildren` but searches only within a `range`.
   */
  function findChildrenInRange(node, range, predicate) {
      const nodesWithPos = [];
      // if (range.from === range.to) {
      //   const nodeAt = node.nodeAt(range.from)
      //   if (nodeAt) {
      //     nodesWithPos.push({
      //       node: nodeAt,
      //       pos: range.from,
      //     })
      //   }
      // }
      node.nodesBetween(range.from, range.to, (child, pos) => {
          if (predicate(child)) {
              nodesWithPos.push({
                  node: child,
                  pos,
              });
          }
      });
      return nodesWithPos;
  }

  function getSchema(extensions) {
      const resolvedExtensions = ExtensionManager.resolve(extensions);
      return getSchemaByResolvedExtensions(resolvedExtensions);
  }

  function generateHTML(doc, extensions) {
      const schema = getSchema(extensions);
      const contentNode = prosemirrorModel.Node.fromJSON(schema, doc);
      return getHTMLFromFragment(contentNode, schema);
  }

  function generateJSON(html, extensions) {
      const schema = getSchema(extensions);
      const dom = elementFromString(html);
      return prosemirrorModel.DOMParser.fromSchema(schema)
          .parse(dom)
          .toJSON();
  }

  /**
   * Returns a node tree with node positions.
   */
  function getDebugJSON(node, startOffset = 0) {
      const nodes = [];
      node.forEach((n, offset) => {
          const from = startOffset + offset;
          const to = from + n.nodeSize;
          const marks = n.marks.map(mark => ({
              type: mark.type.name,
              attrs: { ...mark.attrs },
          }));
          const attrs = { ...n.attrs };
          const content = getDebugJSON(n, from + 1);
          const output = {
              type: n.type.name,
              from,
              to,
          };
          if (Object.keys(attrs).length) {
              output.attrs = attrs;
          }
          if (marks.length) {
              output.marks = marks;
          }
          if (content.length) {
              output.content = content;
          }
          if (n.text) {
              output.text = n.text;
          }
          nodes.push(output);
      });
      return nodes;
  }

  function isNodeSelection(value) {
      return isObject(value) && value instanceof prosemirrorState.NodeSelection;
  }

  function posToDOMRect(view, from, to) {
      const start = view.coordsAtPos(from);
      const end = view.coordsAtPos(to, -1);
      const top = Math.min(start.top, end.top);
      const bottom = Math.max(start.bottom, end.bottom);
      const left = Math.min(start.left, end.left);
      const right = Math.max(start.right, end.right);
      const width = right - left;
      const height = bottom - top;
      const x = left;
      const y = top;
      const data = {
          top,
          bottom,
          left,
          right,
          width,
          height,
          x,
          y,
      };
      return {
          ...data,
          toJSON: () => data,
      };
  }

  exports.Editor = Editor;
  exports.Extension = Extension;
  exports.Mark = Mark;
  exports.Node = Node;
  exports.NodeView = NodeView;
  exports.callOrReturn = callOrReturn;
  exports.extensions = extensions;
  exports.findChildren = findChildren;
  exports.findChildrenInRange = findChildrenInRange;
  exports.findParentNode = findParentNode;
  exports.findParentNodeClosestToPos = findParentNodeClosestToPos;
  exports.generateHTML = generateHTML;
  exports.generateJSON = generateJSON;
  exports.getAttributes = getAttributes;
  exports.getDebugJSON = getDebugJSON;
  exports.getExtensionField = getExtensionField;
  exports.getHTMLFromFragment = getHTMLFromFragment;
  exports.getMarkAttributes = getMarkAttributes;
  exports.getMarkRange = getMarkRange;
  exports.getMarkType = getMarkType;
  exports.getMarksBetween = getMarksBetween;
  exports.getNodeAttributes = getNodeAttributes;
  exports.getNodeType = getNodeType;
  exports.getSchema = getSchema;
  exports.isActive = isActive;
  exports.isList = isList;
  exports.isMarkActive = isMarkActive;
  exports.isNodeActive = isNodeActive;
  exports.isNodeEmpty = isNodeEmpty;
  exports.isNodeSelection = isNodeSelection;
  exports.isTextSelection = isTextSelection;
  exports.markInputRule = markInputRule;
  exports.markPasteRule = markPasteRule;
  exports.mergeAttributes = mergeAttributes;
  exports.nodeInputRule = nodeInputRule;
  exports.posToDOMRect = posToDOMRect;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=tiptap-core.umd.js.map
