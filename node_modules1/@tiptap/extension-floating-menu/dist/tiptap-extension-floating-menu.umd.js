(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tiptap/core'), require('prosemirror-state'), require('tippy.js')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tiptap/core', 'prosemirror-state', 'tippy.js'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@tiptap/extension-floating-menu'] = {}, global.core, global.prosemirrorState, global.tippy));
}(this, (function (exports, core, prosemirrorState, tippy) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var tippy__default = /*#__PURE__*/_interopDefaultLegacy(tippy);

  class FloatingMenuView {
      constructor({ editor, element, view, tippyOptions, }) {
          this.preventHide = false;
          this.mousedownHandler = () => {
              this.preventHide = true;
          };
          this.focusHandler = () => {
              // we use `setTimeout` to make sure `selection` is already updated
              setTimeout(() => this.update(this.editor.view));
          };
          this.blurHandler = ({ event }) => {
              var _a;
              if (this.preventHide) {
                  this.preventHide = false;
                  return;
              }
              if ((event === null || event === void 0 ? void 0 : event.relatedTarget)
                  && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
                  return;
              }
              this.hide();
          };
          this.editor = editor;
          this.element = element;
          this.view = view;
          this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });
          this.editor.on('focus', this.focusHandler);
          this.editor.on('blur', this.blurHandler);
          this.createTooltip(tippyOptions);
          this.element.style.visibility = 'visible';
      }
      createTooltip(options = {}) {
          this.tippy = tippy__default['default'](this.view.dom, {
              duration: 0,
              getReferenceClientRect: null,
              content: this.element,
              interactive: true,
              trigger: 'manual',
              placement: 'right',
              hideOnClick: 'toggle',
              ...options,
          });
      }
      update(view, oldState) {
          const { state, composing } = view;
          const { doc, selection } = state;
          const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);
          if (composing || isSame) {
              return;
          }
          const { $anchor, empty, from, to, } = selection;
          const isRootDepth = $anchor.depth === 1;
          const isNodeEmpty = !selection.$anchor.parent.isLeaf && !selection.$anchor.parent.textContent;
          const isActive = isRootDepth && isNodeEmpty;
          if (!empty || !isActive) {
              this.hide();
              return;
          }
          this.tippy.setProps({
              getReferenceClientRect: () => core.posToDOMRect(view, from, to),
          });
          this.show();
      }
      show() {
          this.tippy.show();
      }
      hide() {
          this.tippy.hide();
      }
      destroy() {
          this.tippy.destroy();
          this.element.removeEventListener('mousedown', this.mousedownHandler);
          this.editor.off('focus', this.focusHandler);
          this.editor.off('blur', this.blurHandler);
      }
  }
  const FloatingMenuPluginKey = new prosemirrorState.PluginKey('menuFloating');
  const FloatingMenuPlugin = (options) => {
      return new prosemirrorState.Plugin({
          key: FloatingMenuPluginKey,
          view: view => new FloatingMenuView({ view, ...options }),
      });
  };

  const FloatingMenu = core.Extension.create({
      name: 'bubbleMenu',
      defaultOptions: {
          element: null,
          tippyOptions: {},
      },
      addProseMirrorPlugins() {
          if (!this.options.element) {
              return [];
          }
          return [
              FloatingMenuPlugin({
                  editor: this.editor,
                  element: this.options.element,
                  tippyOptions: this.options.tippyOptions,
              }),
          ];
      },
  });

  exports.FloatingMenu = FloatingMenu;
  exports.FloatingMenuPlugin = FloatingMenuPlugin;
  exports.FloatingMenuPluginKey = FloatingMenuPluginKey;
  exports.FloatingMenuView = FloatingMenuView;
  exports.default = FloatingMenu;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=tiptap-extension-floating-menu.umd.js.map
