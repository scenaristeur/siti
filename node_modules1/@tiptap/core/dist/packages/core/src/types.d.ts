import { Node as ProseMirrorNode, Mark as ProseMirrorMark, ParseOptions } from 'prosemirror-model';
import { EditorView, Decoration, NodeView, EditorProps } from 'prosemirror-view';
import { EditorState, Transaction } from 'prosemirror-state';
import { Extension } from './Extension';
import { Node } from './Node';
import { Mark } from './Mark';
import { Editor } from './Editor';
import { Commands, ExtensionConfig, NodeConfig, MarkConfig } from '.';
export declare type AnyConfig = ExtensionConfig | NodeConfig | MarkConfig;
export declare type AnyExtension = Extension | Node | Mark;
export declare type Extensions = AnyExtension[];
export declare type ParentConfig<T> = Partial<{
    [P in keyof T]: Required<T>[P] extends (...args: any) => any ? (...args: Parameters<Required<T>[P]>) => ReturnType<Required<T>[P]> : T[P];
}>;
export declare type RemoveThis<T> = T extends (...args: any) => any ? (...args: Parameters<T>) => ReturnType<T> : T;
export declare type MaybeReturnType<T> = T extends (...args: any) => any ? ReturnType<T> : T;
export interface EditorOptions {
    element: Element;
    content: Content;
    extensions: Extensions;
    injectCSS: boolean;
    autofocus: FocusPosition;
    editable: boolean;
    editorProps: EditorProps;
    parseOptions: ParseOptions;
    enableInputRules: boolean;
    enablePasteRules: boolean;
    onBeforeCreate: (props: {
        editor: Editor;
    }) => void;
    onCreate: (props: {
        editor: Editor;
    }) => void;
    onUpdate: (props: {
        editor: Editor;
    }) => void;
    onSelectionUpdate: (props: {
        editor: Editor;
    }) => void;
    onTransaction: (props: {
        editor: Editor;
        transaction: Transaction;
    }) => void;
    onFocus: (props: {
        editor: Editor;
        event: FocusEvent;
    }) => void;
    onBlur: (props: {
        editor: Editor;
        event: FocusEvent;
    }) => void;
    onDestroy: () => void;
}
export declare type HTMLContent = string;
export declare type JSONContent = {
    type: string;
    attrs?: Record<string, any>;
    content?: JSONContent[];
    marks?: {
        type: string;
        attrs?: Record<string, any>;
        [key: string]: any;
    }[];
    text?: string;
    [key: string]: any;
};
export declare type Content = HTMLContent | JSONContent | JSONContent[] | null;
export declare type CommandProps = {
    editor: Editor;
    tr: Transaction;
    commands: SingleCommands;
    can: () => CanCommands;
    chain: () => ChainedCommands;
    state: EditorState;
    view: EditorView;
    dispatch: ((args?: any) => any) | undefined;
};
export declare type Command = (props: CommandProps) => boolean;
export declare type CommandSpec = (...args: any[]) => Command;
export declare type KeyboardShortcutCommand = (props: {
    editor: Editor;
}) => boolean;
export declare type Attribute = {
    default: any;
    rendered?: boolean;
    renderHTML?: ((attributes: Record<string, any>) => Record<string, any> | null) | null;
    parseHTML?: ((element: HTMLElement) => Record<string, any> | null) | null;
    keepOnSplit: boolean;
};
export declare type Attributes = {
    [key: string]: Attribute;
};
export declare type ExtensionAttribute = {
    type: string;
    name: string;
    attribute: Required<Attribute>;
};
export declare type GlobalAttributes = {
    types: string[];
    attributes: {
        [key: string]: Attribute;
    };
}[];
export declare type PickValue<T, K extends keyof T> = T[K];
export declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
export declare type Diff<T extends keyof any, U extends keyof any> = ({
    [P in T]: P;
} & {
    [P in U]: never;
} & {
    [x: string]: never;
})[T];
export declare type Overwrite<T, U> = Pick<T, Diff<keyof T, keyof U>> & U;
export declare type ValuesOf<T> = T[keyof T];
export declare type KeysWithTypeOf<T, Type> = ({
    [P in keyof T]: T[P] extends Type ? P : never;
})[keyof T];
export declare type NodeViewProps = {
    editor: Editor;
    node: ProseMirrorNode;
    decorations: Decoration[];
    selected: boolean;
    extension: Node;
    getPos: () => number;
    updateAttributes: (attributes: Record<string, any>) => void;
    deleteNode: () => void;
};
export declare type NodeViewRendererProps = {
    editor: Editor;
    node: ProseMirrorNode;
    getPos: (() => number) | boolean;
    HTMLAttributes: Record<string, any>;
    decorations: Decoration[];
    extension: Node;
};
export declare type NodeViewRenderer = (props: NodeViewRendererProps) => (NodeView | {});
export declare type UnionCommands = UnionToIntersection<ValuesOf<Pick<Commands, KeysWithTypeOf<Commands, {}>>>>;
export declare type RawCommands = {
    [Item in keyof UnionCommands]: UnionCommands[Item] extends (...args: any[]) => any ? (...args: Parameters<UnionCommands[Item]>) => Command : never;
};
export declare type SingleCommands = {
    [Item in keyof RawCommands]: RawCommands[Item] extends (...args: any[]) => any ? (...args: Parameters<RawCommands[Item]>) => boolean : never;
};
export declare type ChainedCommands = {
    [Item in keyof RawCommands]: RawCommands[Item] extends (...args: any[]) => any ? (...args: Parameters<RawCommands[Item]>) => ChainedCommands : never;
} & {
    run: () => boolean;
};
export declare type CanCommands = SingleCommands & {
    chain: () => ChainedCommands;
};
export declare type FocusPosition = 'start' | 'end' | number | boolean | null;
export declare type Range = {
    from: number;
    to: number;
};
export declare type NodeRange = {
    node: ProseMirrorNode;
    from: number;
    to: number;
};
export declare type MarkRange = {
    mark: ProseMirrorMark;
    from: number;
    to: number;
};
export declare type Predicate = (node: ProseMirrorNode) => boolean;
export declare type NodeWithPos = {
    node: ProseMirrorNode;
    pos: number;
};
