/**
 * Begin license text.
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * End license text.Source Distributions
 */
/**
 * Returns a local store instance
 */
function buildStore() {
    var storage = new Map();
    return {
        setItem: function (key, value) {
            storage.set(key, value);
        },
        getItem: function (key) {
            var result = storage.get(key);
            return result ? result : null;
        },
        removeItem: function (key) {
            storage.delete(key);
        },
        get length() {
            return storage.size;
        },
        clear: function () { return storage.clear(); },
        key: function (index) {
            var iterator = storage.entries();
            var item = iterator.next();
            for (var i = 0; i < index; i++) {
                item = iterator.next();
            }
            return item && item.value ? item.value[0] : null;
        },
    };
}
/**
 * Returns localStore in a browser environment, and a local store instance otherwise
 */
function getLocalStore() {
    if (typeof window !== "undefined" &&
        typeof window.localStorage !== "undefined") {
        return window.localStorage;
    }
    return buildStore();
}

/**
 * Begin license text.
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * End license text.Source Distributions
 */
var CONTEXT_KEY_LOCALE = "i18nextLng";
// Key that specifies a preferred fallback language - e.g. if the user selects
// 'French' as the language for the current page, but there is no French, then
// we'll check if the user has a preferred fallback language, e.g. maybe in
// their profile they have selected 'Spanish' as their preferred fallback.
var CONTEXT_KEY_PREFERRED_FALLBACK_LANGUAGE = "lang_preferred_fallback";
/**
 * Simple class to hold 'context', which could include things like a chosen language, localization settings, process
 * details (like the credentials of the process, time the process started, the process ID, etc.).
 *
 * We can be configured with a storage instance on construction (e.g. to attempt to read values from 'localStorage' in
 * cases when we are deployed within a browser - e.g. a language drop-down might set the current language using a
 * simple key value of say 'i18nLanguage' in localStorage).
 */
var VocabContext = /** @class */ (function () {
    function VocabContext(locale, storage) {
        if (!locale) {
            throw new Error("A new context *MUST* be provided a locale, but none was provided.");
        }
        if (!storage) {
            throw new Error("A new context *MUST* be provided storage (we expect 'localStorage').");
        }
        this._initialLocale = locale;
        this._storage = storage;
        this._storage.setItem(CONTEXT_KEY_LOCALE, locale);
        this._createdAt = Date.now();
    }
    VocabContext.prototype.getLocale = function () {
        var _a;
        return (_a = this._storage.getItem(CONTEXT_KEY_LOCALE)) !== null && _a !== void 0 ? _a : this._initialLocale;
    };
    VocabContext.prototype.setLocale = function (locale) {
        this._storage.setItem(CONTEXT_KEY_LOCALE, locale);
        return this;
    };
    VocabContext.prototype.getInitialLocale = function () {
        return this._initialLocale;
    };
    VocabContext.prototype.getCreatedAt = function () {
        return this._createdAt;
    };
    return VocabContext;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/**
 * Begin license text.
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * End license text.Source Distributions
 */
/** @class */ ((function (_super) {
    __extends(VocabContextError, _super);
    function VocabContextError(context, message, wrappedException) {
        var _this = 
        // The ignore is required because of code coverage bug
        // https://github.com/gotwarlost/istanbul/issues/690
        _super.call(this, message) /* istanbul ignore next */ || this;
        if (wrappedException) {
            if (wrappedException instanceof VocabContextError) {
                _this._wrappedException = wrappedException;
                _this.message = _this.message + "\nContains context error: " + wrappedException.message;
            }
            else if (wrappedException instanceof Error) {
                _this._wrappedException = wrappedException;
                _this.message = _this.message + "\nContains error: " + wrappedException.message;
            }
            else {
                throw new Error("Context error can only wrap ContextErrors or Errors, but got [" + wrappedException + "] (message was [" + message + "]).");
            }
        }
        _this._context = context;
        _this._createdAt = Date.now();
        // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, VocabContextError.prototype);
        return _this;
    }
    VocabContextError.prototype.report = function (level, totalLevels, exception) {
        var _a;
        var result = exception.message;
        var stack = exception.stack ? exception.stack.toString() : "";
        // Ignoring the next line is required for full code coverage, because when
        // testing in a Node environment, it is not possible to have `process`
        // undefined.
        // istanbul ignore next
        if (((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.NODE_ENV) !== "production") {
            result += "\n" + ("Level " + level + " of " + totalLevels + ":\n" + stack);
        }
        return result;
    };
    VocabContextError.prototype.countLevels = function () {
        var result = 1;
        var current = this;
        while (current && current._wrappedException) {
            if (!(current._wrappedException instanceof VocabContextError)) {
                // If we have wrapped a standard exception, then the unwrapping stops,
                //  because standard errors can't wrap other errors.
                current = undefined;
                result++;
            }
            else {
                current = current._wrappedException;
                result++;
            }
        }
        return result;
    };
    VocabContextError.prototype.unwrapException = function () {
        var totalLevels = this.countLevels();
        var level = 1;
        var result = "";
        var current = this;
        while (current !== undefined) {
            result += "\n\n" + this.report(level++, totalLevels, current);
            if (!(current._wrappedException instanceof VocabContextError) &&
                current._wrappedException) {
                result +=
                    "\n\n" + this.report(level++, totalLevels, current._wrappedException);
                // When reaching a plain Error, the unwrapping stops
                current = undefined;
            }
            else {
                // Unwraps the exception until _wrappedException is undefined
                current = current._wrappedException;
            }
        }
        return result;
    };
    VocabContextError.prototype.toString = function () {
        return this.unwrapException();
    };
    VocabContextError.prototype.contains = function (elements) {
        if (!elements) {
            return true;
        }
        var message = this.unwrapException();
        return elements
            .map(function (element) { return message.includes(element); })
            .reduce(function (acc, current) { return acc && current; }, true);
    };
    return VocabContextError;
})(Error));

/**
 * Begin license text.
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * End license text.Source Distributions
 */
var NO_LANGUAGE_TAG = "<No Language>";
// Typically, these would come from a LIT-generated artifact,
// but since those generated artifacts depend on this current, it's
// just much easier to define the constants we need manually here.
var XSD_STRING = "http://www.w3.org/2001/XMLSchema#string";
var RDF_LANGSTRING = "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString";
function isLiteral(term) {
    return term.language !== undefined;
}
/**
 * Class that defines the concept of a multi-lingual literal (as in an RDF
 * String literal). We can add multiple values in different languages, and
 * look them up again.
 * Also supports parameterized string values (using {{0}} placeholders), for
 * which we can provide values when looking them up.
 */
var VocabMultiLingualLiteral = /** @class */ (function () {
    /**
     *
     * @param rdfFactory Expected to provide RDF primitives (e.g. named nodes,
     * literals, etc.).
     * @param iri The IRI for this instance
     * @param values The values (if any) to initialise this instance
     * @param contextMessage Context information (helpful for debugging)
     * @returns {VocabMultiLingualLiteral|*}
     */
    function VocabMultiLingualLiteral(rdfFactory, iri, values, contextMessage) {
        // Implementing the RDFJS Literal interface
        this.termType = "Literal";
        this._rdfFactory = rdfFactory;
        this._iri = iri;
        this._values = values ? values : new Map();
        this._contextMessage = contextMessage ? contextMessage : "<None provided>";
        this._language = undefined;
        this._expandedMessage = undefined;
    }
    Object.defineProperty(VocabMultiLingualLiteral.prototype, "setToEnglish", {
        get: function () {
            this.asLanguage("en");
            return this;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabMultiLingualLiteral.prototype, "value", {
        get: function () {
            var _a, _b;
            return (_b = (_a = this.lookup(false)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : "";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabMultiLingualLiteral.prototype, "language", {
        get: function () {
            if (!this._language || this._language === NO_LANGUAGE_TAG) {
                return "";
            }
            else {
                return this._language;
            }
        },
        enumerable: false,
        configurable: true
    });
    VocabMultiLingualLiteral.prototype.equals = function (other) {
        if (isLiteral(other)) {
            return (this._values.get(other.language || NO_LANGUAGE_TAG) === other.value);
        }
        else {
            return false;
        }
    };
    Object.defineProperty(VocabMultiLingualLiteral.prototype, "datatype", {
        get: function () {
            if (!this.language || this.language == NO_LANGUAGE_TAG) {
                return this._rdfFactory.namedNode(XSD_STRING);
            }
            else {
                return this._rdfFactory.namedNode(RDF_LANGSTRING);
            }
        },
        enumerable: false,
        configurable: true
    });
    VocabMultiLingualLiteral.prototype.getIri = function () {
        return this._iri;
    };
    VocabMultiLingualLiteral.prototype.asLanguage = function (tag) {
        this._language = tag;
        return this;
    };
    VocabMultiLingualLiteral.prototype.addValue = function (value, locale) {
        if (!this._language) {
            this._language = locale;
        }
        this._values.set(locale, value);
        return this;
    };
    VocabMultiLingualLiteral.prototype.lookupEnglish = function (mandatory) {
        return this.asLanguage("en").lookup(mandatory);
    };
    /**
     * Looks up a message in the currently set language, but if none found we
     * use the English message (which code-generators can enforce, so they should
     * always ensure at least an English message for vocab terms).
     *
     * NOTE: If we do use the English default, then we also reset our language
     * tag so that if we are returning an RDF literal it will contain the correct
     * language tag (i.e. 'en'), and not the requested language that didn't exist!
     *
     * @param mandatory Flag - if true, we'll Throw an error if no value found.
     * @returns {*}
     */
    VocabMultiLingualLiteral.prototype.lookup = function (mandatory) {
        var message = this.lookupButDefaultToEnglishOrNoLanguage(mandatory);
        if (message === undefined) {
            return undefined;
        }
        this._expandedMessage = message;
        return this._rdfFactory.literal(message, this.handleNoLanguageTag());
    };
    /**
     * Private method that only looks up the string itself (i.e. will not attempt
     * to wrap in an RDF literal).
     *
     * @param mandatory Flag - if true, we'll Throw an error if no value found.
     * @returns {*}
     */
    VocabMultiLingualLiteral.prototype.lookupButDefaultToEnglishOrNoLanguage = function (mandatory) {
        if (!this._language) {
            if (mandatory) {
                throw new Error("No value has been added to the literal");
            }
            else {
                return undefined;
            }
        }
        var message = this._values.get(this._language);
        if (message) {
            return message;
        }
        else if (mandatory) {
            // NOTE: we explicitly throw here, regardless of our 'throw' parameter.
            throw new Error("MultiLingualLiteral message with IRI [" + this._iri.value + "] required value in language [" + this._language + "], but none found (Context: [" + this._contextMessage + "]).");
        }
        else {
            message = this._values.get("en");
            if (message) {
                this._language = "en";
            }
            else {
                message = this._values.get(NO_LANGUAGE_TAG);
                this._language = NO_LANGUAGE_TAG;
            }
        }
        return message;
    };
    /**
     * TODO: Won't yet handle replacing multiple uses of say {{1}} in a single
     *  string, which I guess it should...!?
     *
     * @param mandatory Flag - if true, we'll Throw an error if no value found.
     * @param rest array of values to be used to replace placeholders in
     * the looked-up message.
     * @returns {*}
     */
    VocabMultiLingualLiteral.prototype.params = function (mandatory) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var message = this.lookupButDefaultToEnglishOrNoLanguage(mandatory);
        // If we failed to find a value at all (and didn't throw!), then return
        // 'undefined'.
        if (message === undefined) {
            return undefined;
        }
        var paramsRequired = message.split("{{").length - 1;
        if (paramsRequired !== rest.length) {
            throw new Error("Setting parameters on LitMultiLingualLiteral with IRI [" + this._iri.value + "] and value [" + message + "] in language [" + this._language + "], but it requires [" + paramsRequired + "] params and we received [" + rest.length + "] (Context: [" + this._contextMessage + "]).");
        }
        for (var i = 0; i < rest.length; i++) {
            var marker = "{{" + i + "}}";
            message = message.replace(marker, rest[i]);
        }
        this._expandedMessage = message;
        return this._rdfFactory.literal(message, this.handleNoLanguageTag());
    };
    /**
     * We use a marker for no-language literals, so this handles that marker
     * and returns the correct RDF tag for 'no-language'.
     *
     * @returns {string}
     */
    VocabMultiLingualLiteral.prototype.handleNoLanguageTag = function () {
        return this._language === NO_LANGUAGE_TAG ? "" : this._language;
    };
    return VocabMultiLingualLiteral;
}());

/**
 * Begin license text.
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * End license text.Source Distributions
 */
/**
 * Simple registry of terms (and their associated meta-data (like labels,
 * comment, message)) in multiple languages.
 *
 * We use localStorage to store all term meta-data, which can only store
 * strings (so we need to expand out the meta-data for each term).
 */
var VocabTermRegistry = /** @class */ (function () {
    function VocabTermRegistry(store) {
        this.store = store;
    }
    VocabTermRegistry.prototype.lookupLabel = function (termIri, language) {
        return this.lookupItem(termIri, language, "label");
    };
    VocabTermRegistry.prototype.updateLabel = function (termIri, language, label) {
        this.updateItem(termIri, language, label, "label");
    };
    VocabTermRegistry.prototype.lookupComment = function (termIri, language) {
        return this.lookupItem(termIri, language, "comment");
    };
    VocabTermRegistry.prototype.updateComment = function (termIri, language, label) {
        this.updateItem(termIri, language, label, "comment");
    };
    VocabTermRegistry.prototype.lookupMessage = function (termIri, language) {
        return this.lookupItem(termIri, language, "message");
    };
    VocabTermRegistry.prototype.updateMessage = function (termIri, language, label) {
        this.updateItem(termIri, language, label, "message");
    };
    VocabTermRegistry.prototype.updateItem = function (termIri, language, label, item) {
        this.store.setItem(termIri + "-" + item + "-" + language, label);
    };
    VocabTermRegistry.prototype.lookupItem = function (termIri, language, item) {
        return this.lookupFullTerm(termIri + "-" + item + "-", language);
    };
    /**
     * Looks up the specified vocabulary term in the specified language. If no
     * value found, will lookup again using the fallback language (as set in our
     * context). If not found again, will fallback to looking up the term in
     * English.
     *
     * @param term
     * @param language
     * @returns {string}
     */
    VocabTermRegistry.prototype.lookupFullTerm = function (term, language) {
        var _a;
        var fallbackLanguage = (_a = this.store.getItem(CONTEXT_KEY_PREFERRED_FALLBACK_LANGUAGE)) !== null && _a !== void 0 ? _a : "en";
        return this.lookupFullTermFallback(term, language, [
            fallbackLanguage,
            "en",
            NO_LANGUAGE_TAG,
        ]);
    };
    /**
     * Looks up the specified vocabulary term in the specified language. If no
     * value found, will lookup again using the provided fallback values one by
     * one until a value is found or there are no additional fallbacks.
     *
     * @param term {string}
     * @param language {string}
     * @param fallback {string[]}
     *
     * @returns {string | undefined}
     */
    VocabTermRegistry.prototype.lookupFullTermFallback = function (term, language, fallback) {
        var result = this.store.getItem("" + term + language);
        if (result) {
            return result;
        }
        else if (fallback.length > 0) {
            return this.lookupFullTermFallback(term, fallback[0], fallback.slice(1));
        }
        else {
            return undefined;
        }
    };
    return VocabTermRegistry;
}());

/**
 * Begin license text.
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * End license text.Source Distributions
 */
var DEFAULT_LOCALE = "en";
/**
 * Class to represent vocabulary terms. We expect derived classes to extend
 * an IRI (e.g. a NamedNode in RDFJS), but we just provide effectively an
 * abstract base class providing meta-data associated with terms in a
 * vocabulary, like labels and comments (in multiple-languages).
 *
 * We can also take a reference to a context storage instance, which can
 * contain various contextual information, such as the current locale, or
 * language settings for an interaction that can be used to lookup context at
 * runtime (e.g. to look up the locale for a term's label at runtime if one is
 * not explicitly asked for).
 *
 * This Turtle snippet may help illustrate what this class supports:
 *
 *   prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
 *   prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
 *   prefix skos:     <http://www.w3.org/2004/02/skos/core#>
 *   prefix ex:   <http://example.com/>
 *
 *   ex:name a rdf:Property ;
 *     rdfs:label "Name" ;
 *     rdfs:label "First name"@en ;
 *     rdfs:label "Nombre"@es ;
 *     rdfs:comment "A person's first name"@en .
 *
 *   ex:errNameTooLong a rdfs:Literal ;
 *     skos:definition "Name must be less than {{0}}, but we got {{1}}"@en .
 *
 * NOTE: Since this class does NOT actually store the IRI value for the vocab
 * term (since we expect derived classes to provide that), testing this
 * class in isolation will result in strange looking (i.e. 'undefined-'
 * prefixed) key values in 'localStorage' since we create those keys based on
 * the term IRI (that we don't store!). Currently this doesn't cause any
 * problems, but it's just something to be aware of!
 */
var VocabTerm = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param iri the IRI for this vocabulary term
     * @param rdfFactory an underlying RDF library that can create IRI's
     * @param contextStorage context for this term
     * @param strict flag if we should be strict. If not strict, we can use the
     * path component of the term's IRI as the English label if no explicit
     * English label (or no-language label) is provided, e.g. 'name' for the
     * term 'http://example.com/vocab#name'.
     */
    function VocabTerm(iri, rdfFactory, contextStorage, strict) {
        // Implementation of the NamedNode interface.
        this.termType = "NamedNode";
        if (typeof iri === "string") {
            this.iri = rdfFactory.namedNode(iri);
        }
        else {
            this.iri = iri;
        }
        this.rdfFactory = rdfFactory;
        if (strict !== undefined) {
            this.strict = strict;
        }
        else {
            this.strict = false;
        }
        this._litSessionContext = new VocabContext(DEFAULT_LOCALE, contextStorage);
        this._registry = new VocabTermRegistry(contextStorage);
        // Create holders for meta-data on this vocabulary term (we could probably
        // lazily create these only if values are actually provided!).
        this._label = new VocabMultiLingualLiteral(rdfFactory, this.iri, undefined, "rdfs:label");
        this._comment = new VocabMultiLingualLiteral(rdfFactory, this.iri, undefined, "rdfs:comment");
        this._message = new VocabMultiLingualLiteral(rdfFactory, this.iri, undefined, "message (should be defined in RDF vocab using: skos:definition)");
        if (!strict) {
            // This can be overwritten if we get an actual no-language label later,
            // which would be perfectly fine.
            this._label.addValue(VocabTerm.extractIriLocalName(iri), NO_LANGUAGE_TAG);
        }
        // Stateful variables defaults.
        this._mandatory = true;
        this._languageOverride = undefined;
        this._isDefinedBy = undefined;
        this._seeAlso = undefined;
        this.resetState();
    }
    Object.defineProperty(VocabTerm.prototype, "value", {
        get: function () {
            return this.iri.value;
        },
        enumerable: false,
        configurable: true
    });
    VocabTerm.prototype.equals = function (other) {
        return this.iri.equals(other);
    };
    Object.defineProperty(VocabTerm.prototype, "mandatory", {
        // Set our mandatory flag - i.e. throws if not as expected.
        get: function () {
            this._mandatory = true;
            return this;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "seeAlso", {
        get: function () {
            return this._seeAlso;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "isDefinedBy", {
        get: function () {
            return this._isDefinedBy;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "asEnglish", {
        // Simple convenience accessor for requesting English.
        get: function () {
            return this.asLanguage("en");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "iriAsString", {
        // Explicitly named alias for getting the IRI of this term as a String.
        get: function () {
            return this.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "labelLiteral", {
        // Accessor for label that uses our LitSessionContext instance.
        get: function () {
            try {
                var language = this.useLanguageOverrideOrGetFromContext();
                return this._label.asLanguage(language).lookup(this._mandatory);
            }
            finally {
                this.resetState();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "label", {
        get: function () {
            var label = this.labelLiteral;
            return label && label.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "commentLiteral", {
        // Accessor for comment that uses our LitSessionContext instance.
        get: function () {
            try {
                var language = this.useLanguageOverrideOrGetFromContext();
                return this._comment.asLanguage(language).lookup(this._mandatory);
            }
            finally {
                this.resetState();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "comment", {
        get: function () {
            var comment = this.commentLiteral;
            return comment && comment.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "messageLiteral", {
        // Accessor for message that uses our LitSessionContext instance.
        get: function () {
            try {
                var language = this.useLanguageOverrideOrGetFromContext();
                return this._message.asLanguage(language).lookup(this._mandatory);
            }
            finally {
                this.resetState();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VocabTerm.prototype, "message", {
        get: function () {
            var message = this.messageLiteral;
            return message && message.value;
        },
        enumerable: false,
        configurable: true
    });
    // Get the IRI of this term as a String (means we can treat this object
    // instance as a string more easily).
    // NOTE: This is *NOT* an accessor, but deliberately overriding the
    // 'toString()' method on the base Object.
    VocabTerm.prototype.toString = function () {
        return this.value;
    };
    VocabTerm.prototype.messageParamsLiteral = function () {
        var _a;
        var rest = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rest[_i] = arguments[_i];
        }
        var language = this.useLanguageOverrideOrGetFromContext();
        try {
            return (_a = this._message
                .asLanguage(language))
                .params.apply(_a, __spreadArrays([this._mandatory], rest));
        }
        finally {
            this.resetState();
        }
    };
    VocabTerm.prototype.messageParams = function () {
        var rest = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rest[_i] = arguments[_i];
        }
        var messageParams = this.messageParamsLiteral.apply(this, rest);
        return messageParams && messageParams.value;
    };
    VocabTerm.prototype.resetState = function () {
        this._languageOverride = undefined;
        this._mandatory = false;
    };
    VocabTerm.prototype.addSeeAlso = function (value) {
        if (!this._seeAlso) {
            this._seeAlso = new Set();
        }
        this._seeAlso.add(value);
        return this;
    };
    VocabTerm.prototype.addIsDefinedBy = function (value) {
        this._isDefinedBy = value;
        return this;
    };
    VocabTerm.prototype.addLabelNoLanguage = function (value) {
        return this.addLabel(value, NO_LANGUAGE_TAG);
    };
    VocabTerm.prototype.addLabel = function (value, language) {
        this.validateAddParams(value, language, "label");
        this._label.addValue(value, language);
        this._registry.updateLabel(this.value, language, value);
        return this;
    };
    VocabTerm.prototype.addCommentNoLanguage = function (value) {
        return this.addComment(value, NO_LANGUAGE_TAG);
    };
    VocabTerm.prototype.addComment = function (value, language) {
        this.validateAddParams(value, language, "comment");
        this._comment.addValue(value, language);
        this._registry.updateComment(this.value, language, value);
        return this;
    };
    VocabTerm.prototype.addMessageNoLanguage = function (value) {
        return this.addMessage(value, NO_LANGUAGE_TAG);
    };
    VocabTerm.prototype.addMessage = function (value, language) {
        this.validateAddParams(value, language, "message");
        this._message.addValue(value, language);
        this._registry.updateMessage(this.value, language, value);
        return this;
    };
    /**
     * Ensure we always provide both a value and a lnaguage tag for that value.
     *
     * @param value the test of the value
     * @param language the language tag for the value
     * @param what what kind of value we are adding
     */
    VocabTerm.prototype.validateAddParams = function (value, language, what) {
        if (value === undefined || value === null) {
            throw new Error("Attempted to add a non-existent [" + what + "] value to vocab term");
        }
        if (!language) {
            throw new Error("Attempted to add the [" + what + "] value [" + value + "], but without specifying a language");
        }
        return this;
    };
    VocabTerm.prototype.useLanguageOverrideOrGetFromContext = function () {
        return this._languageOverride === undefined
            ? this._litSessionContext.getLocale()
            : this._languageOverride;
    };
    VocabTerm.prototype.asLanguage = function (language) {
        // An empty string is converted to the NO_LANGUAGE_TAG.
        this._languageOverride = language || NO_LANGUAGE_TAG;
        return this;
    };
    /**
     * Extract the local name from the specified IRI (can be a primitive string or
     * a NamedNode).
     *
     * @param stringOrNamedNode The IRI to extract from.
     * @returns {string}
     */
    VocabTerm.extractIriLocalName = function (stringOrNamedNode) {
        var iri = this.isString(stringOrNamedNode)
            ? stringOrNamedNode
            : stringOrNamedNode.value;
        var hashPos = iri.lastIndexOf("#");
        if (hashPos > -1) {
            return iri.substring(hashPos + 1);
        }
        var lastSlashPos = iri.lastIndexOf("/");
        if (lastSlashPos === -1 ||
            (iri.toLowerCase().startsWith("http") &&
                lastSlashPos < (iri.toLowerCase().startsWith("https") ? 8 : 7))) {
            throw Error("Expected hash fragment ('#') or slash ('/') (other than 'https://...') in IRI [" + iri + "]");
        }
        else {
            return iri.substring(lastSlashPos + 1);
        }
    };
    /**
     * Simple method to determine if the specified value is a primitive String.
  
     * @param value The value to evaluate.
     * @returns {boolean} true if String, else false.
     */
    VocabTerm.isString = function (value) {
        return typeof value === "string" || value instanceof String;
    };
    /**
     * Simply treat the value as an IRI if it starts with 'http://' or 'https://'
     * (case-insensitive).
     *
     * @param value
     * @returns {boolean}
     */
    VocabTerm.isStringIri = function (value) {
        if (!this.isString(value)) {
            return false;
        }
        var valueLower = value.toLowerCase();
        return (valueLower.startsWith("http://") || valueLower.startsWith("https://"));
    };
    return VocabTerm;
}());

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var BlankNode_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlankNode = void 0;
/**
 * A term that represents an RDF blank node with a label.
 */
class BlankNode {
    constructor(value) {
        this.termType = 'BlankNode';
        this.value = value;
    }
    equals(other) {
        return !!other && other.termType === 'BlankNode' && other.value === this.value;
    }
}
exports.BlankNode = BlankNode;
//# sourceMappingURL=BlankNode.js.map
});

var DefaultGraph_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultGraph = void 0;
/**
 * A singleton term instance that represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */
class DefaultGraph {
    constructor() {
        this.termType = 'DefaultGraph';
        this.value = '';
        // Private constructor
    }
    equals(other) {
        return !!other && other.termType === 'DefaultGraph';
    }
}
exports.DefaultGraph = DefaultGraph;
DefaultGraph.INSTANCE = new DefaultGraph();
//# sourceMappingURL=DefaultGraph.js.map
});

var NamedNode_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamedNode = void 0;
/**
 * A term that contains an IRI.
 */
class NamedNode {
    constructor(value) {
        this.termType = 'NamedNode';
        this.value = value;
    }
    equals(other) {
        return !!other && other.termType === 'NamedNode' && other.value === this.value;
    }
}
exports.NamedNode = NamedNode;
//# sourceMappingURL=NamedNode.js.map
});

var Literal_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Literal = void 0;

/**
 * A term that represents an RDF literal, containing a string with an optional language tag or datatype.
 */
class Literal {
    constructor(value, languageOrDatatype) {
        this.termType = 'Literal';
        this.value = value;
        if (typeof languageOrDatatype === 'string') {
            this.language = languageOrDatatype;
            this.datatype = Literal.RDF_LANGUAGE_STRING;
        }
        else if (languageOrDatatype) {
            this.language = '';
            this.datatype = languageOrDatatype;
        }
        else {
            this.language = '';
            this.datatype = Literal.XSD_STRING;
        }
    }
    equals(other) {
        return !!other && other.termType === 'Literal' && other.value === this.value &&
            other.language === this.language && other.datatype.equals(this.datatype);
    }
}
exports.Literal = Literal;
Literal.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
Literal.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');
//# sourceMappingURL=Literal.js.map
});

var Quad_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Quad = void 0;
/**
 * An instance of DefaultGraph represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */
class Quad {
    constructor(subject, predicate, object, graph) {
        this.termType = 'Quad';
        this.value = '';
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
        this.graph = graph;
    }
    equals(other) {
        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.
        return !!other && (other.termType === 'Quad' || !other.termType) &&
            this.subject.equals(other.subject) &&
            this.predicate.equals(other.predicate) &&
            this.object.equals(other.object) &&
            this.graph.equals(other.graph);
    }
}
exports.Quad = Quad;
//# sourceMappingURL=Quad.js.map
});

var Variable_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Variable = void 0;
/**
 * A term that represents a variable.
 */
class Variable {
    constructor(value) {
        this.termType = 'Variable';
        this.value = value;
    }
    equals(other) {
        return !!other && other.termType === 'Variable' && other.value === this.value;
    }
}
exports.Variable = Variable;
//# sourceMappingURL=Variable.js.map
});

var DataFactory_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataFactory = void 0;






let dataFactoryCounter = 0;
/**
 * A factory for instantiating RDF terms and quads.
 */
class DataFactory {
    constructor(options) {
        this.blankNodeCounter = 0;
        options = options || {};
        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;
    }
    /**
     * @param value The IRI for the named node.
     * @return A new instance of NamedNode.
     * @see NamedNode
     */
    namedNode(value) {
        return new NamedNode_1.NamedNode(value);
    }
    /**
     * @param value The optional blank node identifier.
     * @return A new instance of BlankNode.
     *         If the `value` parameter is undefined a new identifier
     *         for the blank node is generated for each call.
     * @see BlankNode
     */
    blankNode(value) {
        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
    }
    /**
     * @param value              The literal value.
     * @param languageOrDatatype The optional language or datatype.
     *                           If `languageOrDatatype` is a NamedNode,
     *                           then it is used for the value of `NamedNode.datatype`.
     *                           Otherwise `languageOrDatatype` is used for the value
     *                           of `NamedNode.language`.
     * @return A new instance of Literal.
     * @see Literal
     */
    literal(value, languageOrDatatype) {
        return new Literal_1.Literal(value, languageOrDatatype);
    }
    /**
     * This method is optional.
     * @param value The variable name
     * @return A new instance of Variable.
     * @see Variable
     */
    variable(value) {
        return new Variable_1.Variable(value);
    }
    /**
     * @return An instance of DefaultGraph.
     */
    defaultGraph() {
        return DefaultGraph_1.DefaultGraph.INSTANCE;
    }
    /**
     * @param subject   The quad subject term.
     * @param predicate The quad predicate term.
     * @param object    The quad object term.
     * @param graph     The quad graph term.
     * @return A new instance of Quad.
     * @see Quad
     */
    quad(subject, predicate, object, graph) {
        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());
    }
    /**
     * Create a deep copy of the given term using this data factory.
     * @param original An RDF term.
     * @return A deep copy of the given term.
     */
    fromTerm(original) {
        // TODO: remove nasty any casts when this TS bug has been fixed:
        //  https://github.com/microsoft/TypeScript/issues/26933
        switch (original.termType) {
            case 'NamedNode':
                return this.namedNode(original.value);
            case 'BlankNode':
                return this.blankNode(original.value);
            case 'Literal':
                if (original.language) {
                    return this.literal(original.value, original.language);
                }
                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {
                    return this.literal(original.value, this.fromTerm(original.datatype));
                }
                return this.literal(original.value);
            case 'Variable':
                return this.variable(original.value);
            case 'DefaultGraph':
                return this.defaultGraph();
            case 'Quad':
                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));
        }
    }
    /**
     * Create a deep copy of the given quad using this data factory.
     * @param original An RDF quad.
     * @return A deep copy of the given quad.
     */
    fromQuad(original) {
        return this.fromTerm(original);
    }
    /**
     * Reset the internal blank node counter.
     */
    resetBlankNodeCounter() {
        this.blankNodeCounter = 0;
    }
}
exports.DataFactory = DataFactory;
//# sourceMappingURL=DataFactory.js.map
});

var rdfDataFactory = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(BlankNode_1, exports);
__exportStar(DataFactory_1, exports);
__exportStar(DefaultGraph_1, exports);
__exportStar(Literal_1, exports);
__exportStar(NamedNode_1, exports);
__exportStar(Quad_1, exports);
__exportStar(Variable_1, exports);
//# sourceMappingURL=index.js.map
});

/**
 * MIT License
 *
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var rdfFactory$8 = new rdfDataFactory.DataFactory();
function _NS$8(localName) {
    return rdfFactory$8.namedNode("https://inrupt.com/vocab/solid-meta-server-creational#" + localName);
}
// Add 'any' type annotation in case this vocab includes 'NamedNode' instances,
// for example instances of Constant IRIs (TypeScript compiler will complain of
// "semantic error TS2742" otherwise).
/**
 * The Solid vocabulary providing terms (e.g. classes, properties and text strings (e.g.
 informative labels or error messages) used by Solid servers at server creation time.
 */
var SOLID_META_SERVER_CREATIONAL = {
    PREFIX: "solid-meta-server-creational",
    NAMESPACE: "https://inrupt.com/vocab/solid-meta-server-creational#",
    PREFIX_AND_NAMESPACE: { "solid-meta-server-creational": "https://inrupt.com/vocab/solid-meta-server-creational#" },
    NS: _NS$8,
    // *******************
    // All the Properties.
    // *******************
    /**
     * The root subject for creation-time server-generated metadata.
   The idea for subject roots is that we could build up an entire graph of
   metadata (i.e. as processing progresses along a chain of processors, with each
   processor enriching this metadata with their specific metadata), and this
   term defines the root term of that graph.
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-meta-server-creational#
     */
    subjectRoot: new VocabTerm(_NS$8("subjectRoot"), rdfFactory$8, getLocalStore(), false)
        .addIsDefinedBy(_NS$8("https://inrupt.com/vocab/solid-meta-server-creational#"))
        .addLabel("Subject root", "en")
        .addComment("The root subject for creation-time server-generated metadata.\n The idea for subject roots is that we could build up an entire graph of\n metadata (i.e. as processing progresses along a chain of processors, with each\n processor enriching this metadata with their specific metadata), and this\n term defines the root term of that graph.", "en"),
    /**
     * Host name of the server processing this request.
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-meta-server-creational#
     */
    hostName: new VocabTerm(_NS$8("hostName"), rdfFactory$8, getLocalStore(), false)
        .addIsDefinedBy(_NS$8("https://inrupt.com/vocab/solid-meta-server-creational#"))
        .addLabel("Subject root", "en")
        .addComment("Host name of the server processing this request.", "en"),
    /**
     * Host IP address of the server processing this request.
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-meta-server-creational#
     */
    hostIpAddress: new VocabTerm(_NS$8("hostIpAddress"), rdfFactory$8, getLocalStore(), false)
        .addIsDefinedBy(_NS$8("https://inrupt.com/vocab/solid-meta-server-creational#"))
        .addLabel("Host IP address", "en")
        .addComment("Host IP address of the server processing this request.", "en"),
    /**
     * Timestamp this server was instantiated.
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-meta-server-creational#
     */
    createdTimestamp: new VocabTerm(_NS$8("createdTimestamp"), rdfFactory$8, getLocalStore(), false)
        .addIsDefinedBy(_NS$8("https://inrupt.com/vocab/solid-meta-server-creational#"))
        .addLabel("Created timestamp", "en")
        .addComment("Timestamp this server was instantiated.", "en"),
};

/**
 * MIT License
 *
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var rdfFactory$7 = new rdfDataFactory.DataFactory();
function _NS$7(localName) {
    return rdfFactory$7.namedNode("https://inrupt.com/vocab/solid-meta-server-runtime#" + localName);
}
// Add 'any' type annotation in case this vocab includes 'NamedNode' instances,
// for example instances of Constant IRIs (TypeScript compiler will complain of
// "semantic error TS2742" otherwise).
/**
 * The Solid vocabulary providing terms (e.g. classes, properties and text strings (e.g.
 informative labels or error messages) used by Solid servers at server creation time.
 */
var SOLID_META_SERVER_RUNTIME = {
    PREFIX: "solid-meta-server-runtime",
    NAMESPACE: "https://inrupt.com/vocab/solid-meta-server-runtime#",
    PREFIX_AND_NAMESPACE: { "solid-meta-server-runtime": "https://inrupt.com/vocab/solid-meta-server-runtime#" },
    NS: _NS$7,
    // *******************
    // All the Properties.
    // *******************
    /**
     * The root subject for runtime server-generated metadata.
   The idea for subject roots is that we could build up an entire graph of
   metadata (i.e. as processing progresses along a chain of processors, with each
   processor enriching this metadata with their specific metadata), and this
   term defines the root term of that graph.
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-meta-server-runtime#
     */
    subjectRoot: new VocabTerm(_NS$7("subjectRoot"), rdfFactory$7, getLocalStore(), false)
        .addIsDefinedBy(_NS$7("https://inrupt.com/vocab/solid-meta-server-runtime#"))
        .addLabel("Subject root", "en")
        .addComment("The root subject for runtime server-generated metadata.\n The idea for subject roots is that we could build up an entire graph of\n metadata (i.e. as processing progresses along a chain of processors, with each\n processor enriching this metadata with their specific metadata), and this\n term defines the root term of that graph.", "en"),
    /**
     * Timestamp this request was received at this server.
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-meta-server-runtime#
     */
    requestReceivedTimestamp: new VocabTerm(_NS$7("requestReceivedTimestamp"), rdfFactory$7, getLocalStore(), false)
        .addIsDefinedBy(_NS$7("https://inrupt.com/vocab/solid-meta-server-runtime#"))
        .addLabel("Request received timestamp", "en")
        .addComment("Timestamp this request was received at this server.", "en"),
};

/**
 * MIT License
 *
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var rdfFactory$6 = new rdfDataFactory.DataFactory();
function _NS$6(localName) {
    return rdfFactory$6.namedNode("https://inrupt.com/vocab/solid-meta-client#" + localName);
}
// Add 'any' type annotation in case this vocab includes 'NamedNode' instances,
// for example instances of Constant IRIs (TypeScript compiler will complain of
// "semantic error TS2742" otherwise).
/**
 * The Solid vocabulary providing terms (e.g. classes, properties and text strings (e.g.
 informative labels or error messages) used by Solid clients.
 */
var SOLID_META_CLIENT = {
    PREFIX: "solid-meta-client",
    NAMESPACE: "https://inrupt.com/vocab/solid-meta-client#",
    PREFIX_AND_NAMESPACE: { "solid-meta-client": "https://inrupt.com/vocab/solid-meta-client#" },
    NS: _NS$6,
    // *******************
    // All the Properties.
    // *******************
    /**
     * The root subject for client-generated metadata.
   The idea for subject roots is that we could build up an entire graph of
   metadata (i.e. as processing progresses along a chain of processors, with each
   processor enriching this metadata with their specific metadata), and this
   term defines the root term of that graph.
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-meta-client#
     */
    subjectRoot: new VocabTerm(_NS$6("subjectRoot"), rdfFactory$6, getLocalStore(), false)
        .addIsDefinedBy(_NS$6("https://inrupt.com/vocab/solid-meta-client#"))
        .addLabel("Subject root", "en")
        .addComment("The root subject for client-generated metadata.\n The idea for subject roots is that we could build up an entire graph of\n metadata (i.e. as processing progresses along a chain of processors, with each\n processor enriching this metadata with their specific metadata), and this\n term defines the root term of that graph.", "en"),
};

/**
 * MIT License
 *
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var rdfFactory$5 = new rdfDataFactory.DataFactory();
function _NS$5(localName) {
    return rdfFactory$5.namedNode("https://inrupt.com/vocab/solid-meta-acl#" + localName);
}
// Add 'any' type annotation in case this vocab includes 'NamedNode' instances,
// for example instances of Constant IRIs (TypeScript compiler will complain of
// "semantic error TS2742" otherwise).
/**
 * The Solid vocabulary providing terms (e.g. classes, properties and text strings (e.g.
 informative labels or error messages) used by the Solid ACL system.
 */
var SOLID_META_ACL = {
    PREFIX: "solid-meta-acl",
    NAMESPACE: "https://inrupt.com/vocab/solid-meta-acl#",
    PREFIX_AND_NAMESPACE: { "solid-meta-acl": "https://inrupt.com/vocab/solid-meta-acl#" },
    NS: _NS$5,
    // *******************
    // All the Properties.
    // *******************
    /**
     * The root subject for ACL metadata.
   The idea for subject roots is that we could build up an entire graph of
   metadata (i.e. as processing progresses along a chain of processors, with each
   processor enriching this metadata with their specific metadata), and this
   term defines the root term of that graph.
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-meta-acl#
     */
    subjectRoot: new VocabTerm(_NS$5("subjectRoot"), rdfFactory$5, getLocalStore(), false)
        .addIsDefinedBy(_NS$5("https://inrupt.com/vocab/solid-meta-acl#"))
        .addLabel("Subject root", "en")
        .addComment("The root subject for ACL metadata.\n The idea for subject roots is that we could build up an entire graph of\n metadata (i.e. as processing progresses along a chain of processors, with each\n processor enriching this metadata with their specific metadata), and this\n term defines the root term of that graph.", "en"),
    /**
     * The URI that contains the ACL
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-meta-acl#
     */
    aclUri: new VocabTerm(_NS$5("aclUri"), rdfFactory$5, getLocalStore(), false)
        .addIsDefinedBy(_NS$5("https://inrupt.com/vocab/solid-meta-acl#"))
        .addLabel("ACL URI", "en")
        .addComment("The URI that contains the ACL", "en"),
};

/**
 * MIT License
 *
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var rdfFactory$4 = new rdfDataFactory.DataFactory();
function _NS$4(localName) {
    return rdfFactory$4.namedNode("https://inrupt.com/vocab/solid-service-common#" + localName);
}
// Add 'any' type annotation in case this vocab includes 'NamedNode' instances,
// for example instances of Constant IRIs (TypeScript compiler will complain of
// "semantic error TS2742" otherwise).
/**
 * The Solid vocabulary providing terms (e.g. classes, properties and text strings (e.g.
 informative labels or error messages) commonly used across Solid services.
 */
var SOLID_SERVICE_COMMON = {
    PREFIX: "solid-service-common",
    NAMESPACE: "https://inrupt.com/vocab/solid-service-common#",
    PREFIX_AND_NAMESPACE: { "solid-service-common": "https://inrupt.com/vocab/solid-service-common#" },
    NS: _NS$4,
    // *******************
    // All the Literals.
    // *******************
    /**
     * Failed to process incoming message as RDF
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-service-common#
     */
    errFailedToProcessIncomingRdf: new VocabTerm(_NS$4("errFailedToProcessIncomingRdf"), rdfFactory$4, getLocalStore(), false)
        .addIsDefinedBy(_NS$4("https://inrupt.com/vocab/solid-service-common#"))
        .addMessage("Failed to process incoming message as RDF", "en"),
    /**
     * Incoming request validated as RDF (it contains [{{0}}] triples!)
     *
     * Defined by the vocabulary: https://inrupt.com/vocab/solid-service-common#
     */
    msgRequestValidatedAsRdf: new VocabTerm(_NS$4("msgRequestValidatedAsRdf"), rdfFactory$4, getLocalStore(), false)
        .addIsDefinedBy(_NS$4("https://inrupt.com/vocab/solid-service-common#"))
        .addMessage("Incoming request validated as RDF (it contains [{{0}}] triples!)", "en"),
};

/**
 * MIT License
 *
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var rdfFactory$3 = new rdfDataFactory.DataFactory();
function _NS$3(localName) {
    return rdfFactory$3.namedNode("http://www.w3.org/ns/auth/acl#" + localName);
}
// Add 'any' type annotation in case this vocab includes 'NamedNode' instances,
// for example instances of Constant IRIs (TypeScript compiler will complain of
// "semantic error TS2742" otherwise).
/**
 * [Generator provided] - Web Access Control Vocabulary
 */
var ACL = {
    PREFIX: "acl",
    NAMESPACE: "http://www.w3.org/ns/auth/acl#",
    PREFIX_AND_NAMESPACE: { "acl": "http://www.w3.org/ns/auth/acl#" },
    NS: _NS$3,
    // *****************
    // All the Classes.
    // *****************
    /**
     * Any kind of access to a resource. Don't use this, use R W and RW
     */
    Access: new VocabTerm(_NS$3("Access"), rdfFactory$3, getLocalStore(), false)
        .addCommentNoLanguage("Any kind of access to a resource. Don't use this, use R W and RW"),
    /**
     * Append accesses are specific write access which only add information, and do not remove information.
      For text files, for example, append access allows bytes to be added onto the end of the file.
      For RDF graphs, Append access allows adds triples to the graph but does not remove any.
      Append access is useful for dropbox functionality.
      Dropbox can be used for link notification, which the information added is a notification
      that a some link has been made elsewhere relevant to the given resource.
      
     */
    Append: new VocabTerm(_NS$3("Append"), rdfFactory$3, getLocalStore(), false)
        .addLabel("append", "en")
        .addCommentNoLanguage("Append accesses are specific write access which only add information, and do not remove information.\n    For text files, for example, append access allows bytes to be added onto the end of the file.\n    For RDF graphs, Append access allows adds triples to the graph but does not remove any.\n    Append access is useful for dropbox functionality.\n    Dropbox can be used for link notification, which the information added is a notification\n    that a some link has been made elsewhere relevant to the given resource.\n    "),
    /**
     * write
     */
    Write: new VocabTerm(_NS$3("Write"), rdfFactory$3, getLocalStore(), false)
        .addLabel("write", "en"),
    /**
     * A class of agents who have been authenticated.
  In other words, anyone can access this resource, but not anonymously.
  The social expectation is that the authentication process will provide an
  identify and a name, or pseudonym.
  (A new ID should not be minted for every access: the intent is that the user
  is able to continue to use the ID for continues interactions with peers,
  and for example to develop a reputation)
  
     */
    AuthenticatedAgent: new VocabTerm(_NS$3("AuthenticatedAgent"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("Anyone authenticated")
        .addCommentNoLanguage("A class of agents who have been authenticated.\nIn other words, anyone can access this resource, but not anonymously.\nThe social expectation is that the authentication process will provide an\nidentify and a name, or pseudonym.\n(A new ID should not be minted for every access: the intent is that the user\nis able to continue to use the ID for continues interactions with peers,\nand for example to develop a reputation)\n"),
    /**
     * An element of access control,
      allowing agent to agents access of some kind to resources or classes of resources
     */
    Authorization: new VocabTerm(_NS$3("Authorization"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("authorization")
        .addCommentNoLanguage("An element of access control,\n    allowing agent to agents access of some kind to resources or classes of resources"),
    /**
     * Allows read/write access to the ACL for the resource(s)
     */
    Control: new VocabTerm(_NS$3("Control"), rdfFactory$3, getLocalStore(), false)
        .addLabel("control", "en")
        .addCommentNoLanguage("Allows read/write access to the ACL for the resource(s)"),
    /**
     * An Origin is basically a web site
          (Note WITHOUT the trailing slash after the domain name and port in its URI)
          and is the basis for controlling access to data by web apps
          in the Same Origin Model of web security.
          All scripts from the same origin are given the same right.
     *
     * See also:
     *  - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin
     */
    Origin: new VocabTerm(_NS$3("Origin"), rdfFactory$3, getLocalStore(), false)
        .addSeeAlso(_NS$3("https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin"))
        .addLabelNoLanguage("Origin")
        .addCommentNoLanguage("An Origin is basically a web site\n        (Note WITHOUT the trailing slash after the domain name and port in its URI)\n        and is the basis for controlling access to data by web apps\n        in the Same Origin Model of web security.\n        All scripts from the same origin are given the same right."),
    /**
     * The class of read operations
     */
    Read: new VocabTerm(_NS$3("Read"), rdfFactory$3, getLocalStore(), false)
        .addLabel("read", "en")
        .addCommentNoLanguage("The class of read operations"),
    // *******************
    // All the Properties.
    // *******************
    /**
     * The Access Control file for this information resource.
          This may of course be a virtual resource implemented by the access control system.
          Note also HTTP's header  Link:  foo.meta ;rel=meta can be used for this.
     */
    accessControl: new VocabTerm(_NS$3("accessControl"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("access control")
        .addCommentNoLanguage("The Access Control file for this information resource.\n        This may of course be a virtual resource implemented by the access control system.\n        Note also HTTP's header  Link:  foo.meta ;rel=meta can be used for this."),
    /**
     * The information resource to which access is being granted.
     */
    accessTo: new VocabTerm(_NS$3("accessTo"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("to")
        .addCommentNoLanguage("The information resource to which access is being granted."),
    /**
     * A class of information resources to which access is being granted.
     */
    accessToClass: new VocabTerm(_NS$3("accessToClass"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("to all in")
        .addCommentNoLanguage("A class of information resources to which access is being granted."),
    /**
     * A person or social entity to being given the right
     */
    agent: new VocabTerm(_NS$3("agent"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("agent")
        .addCommentNoLanguage("A person or social entity to being given the right"),
    /**
     * A class of persons or social entities to being given the right
     */
    agentClass: new VocabTerm(_NS$3("agentClass"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("agent class")
        .addCommentNoLanguage("A class of persons or social entities to being given the right"),
    /**
     * A group of persons or social entities to being given the right.
            The right is given to any entity which is a vcard:member of the group,
            as defined by the document received when the Group is dereferenced.
     */
    agentGroup: new VocabTerm(_NS$3("agentGroup"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("agent group")
        .addCommentNoLanguage("A group of persons or social entities to being given the right.\n          The right is given to any entity which is a vcard:member of the group,\n          as defined by the document received when the Group is dereferenced."),
    /**
     * If a resource has no ACL file (it is 404),
          then access to the resource if given by the ACL of the immediately
          containing directory, or failing that (404) the ACL of the recursively next
          containing directory which has an ACL file.
          Within that ACL file,
          any Authentication which has that directory as its acl:default applies to the
          resource. (The highest directory must have an ACL file.)
  
     */
    default: new VocabTerm(_NS$3("default"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("default access for things in this")
        .addCommentNoLanguage("If a resource has no ACL file (it is 404),\n        then access to the resource if given by the ACL of the immediately\n        containing directory, or failing that (404) the ACL of the recursively next\n        containing directory which has an ACL file.\n        Within that ACL file,\n        any Authentication which has that directory as its acl:default applies to the\n        resource. (The highest directory must have an ACL file.)\n"),
    /**
     * THIS IS OBSOLETE AS OF 2017-08-01.   See 'default'.
          Was: A directory for which this authorization is used for new files in the directory.
     */
    defaultForNew: new VocabTerm(_NS$3("defaultForNew"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("default access for new things in the object")
        .addCommentNoLanguage("THIS IS OBSOLETE AS OF 2017-08-01.   See 'default'.\n        Was: A directory for which this authorization is used for new files in the directory."),
    /**
     * Delegates a person or another agent to act on behalf of the agent.
      For example, Alice delegates Bob to act on behalf of Alice for ACL purposes.
     */
    delegates: new VocabTerm(_NS$3("delegates"), rdfFactory$3, getLocalStore(), false)
        .addLabel("delegates", "en")
        .addCommentNoLanguage("Delegates a person or another agent to act on behalf of the agent.\n    For example, Alice delegates Bob to act on behalf of Alice for ACL purposes."),
    /**
     * A mode of access such as read or write.
     */
    mode: new VocabTerm(_NS$3("mode"), rdfFactory$3, getLocalStore(), false)
        .addLabelNoLanguage("access mode")
        .addCommentNoLanguage("A mode of access such as read or write."),
    /**
     * A web application, identified by its Origin, such as
          <https://scripts.example.com>, being given the right.
          When a user of the web application at a certain origin accesses the server,
          then the browser sets the Origin: header to warn that a possibly untrusted webapp
          is being used.
          Then, BOTH the user AND the origin must have the required access.
     *
     * See also:
     *  - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin
     */
    origin: new VocabTerm(_NS$3("origin"), rdfFactory$3, getLocalStore(), false)
        .addSeeAlso(_NS$3("https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin"))
        .addLabelNoLanguage("origin")
        .addCommentNoLanguage("A web application, identified by its Origin, such as\n        <https://scripts.example.com>, being given the right.\n        When a user of the web application at a certain origin accesses the server,\n        then the browser sets the Origin: header to warn that a possibly untrusted webapp\n        is being used.\n        Then, BOTH the user AND the origin must have the required access."),
    /**
     * The person or other agent which owns this.
      For example, the owner of a file in a filesystem.
      There is a sense of right to control.   Typically defaults to the agent who craeted
      something but can be changed.
     */
    owner: new VocabTerm(_NS$3("owner"), rdfFactory$3, getLocalStore(), false)
        .addLabel("owner", "en")
        .addCommentNoLanguage("The person or other agent which owns this.\n    For example, the owner of a file in a filesystem.\n    There is a sense of right to control.   Typically defaults to the agent who craeted\n    something but can be changed."),
};

/**
 * MIT License
 *
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var rdfFactory$2 = new rdfDataFactory.DataFactory();
function _NS$2(localName) {
    return rdfFactory$2.namedNode("http://www.w3.org/ns/solid/acp#" + localName);
}
// Add 'any' type annotation in case this vocab includes 'NamedNode' instances,
// for example instances of Constant IRIs (TypeScript compiler will complain of
// "semantic error TS2742" otherwise).
/**
 * A vocabulary to structure policy-based access controls for the Solid ecosystem.
 */
var ACP = {
    PREFIX: "acp",
    NAMESPACE: "http://www.w3.org/ns/solid/acp#",
    PREFIX_AND_NAMESPACE: { "acp": "http://www.w3.org/ns/solid/acp#" },
    NS: _NS$2,
    // *****************
    // All the Classes.
    // *****************
    /**
     * Access Control statements associate an AccessControlResource with specific Policy definitions.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    AccessControl: new VocabTerm(_NS$2("AccessControl"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("Access Control", "en")
        .addComment("Access Control statements associate an AccessControlResource with specific Policy definitions.", "en"),
    /**
     * An RDF resource that includes AccessControl statements
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    AccessControlResource: new VocabTerm(_NS$2("AccessControlResource"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("Access Control Resource", "en")
        .addComment("An RDF resource that includes AccessControl statements", "en"),
    /**
     * A Policy defines a collection of access modes along with the conditions under which the policy is applied.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    Policy: new VocabTerm(_NS$2("Policy"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("Access Policy", "en")
        .addComment("A Policy defines a collection of access modes along with the conditions under which the policy is applied.", "en"),
    /**
     * A Rule defines which agent(s), group(s) and client application(s) match a Policy filter
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    Rule: new VocabTerm(_NS$2("Rule"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("Rule", "en")
        .addComment("A Rule defines which agent(s), group(s) and client application(s) match a Policy filter", "en"),
    /**
     * An abstract access mode. This class should not be used directly. Instead, please use Read, Write and Append
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    AccessMode: new VocabTerm(_NS$2("AccessMode"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("Access Mode", "en")
        .addComment("An abstract access mode. This class should not be used directly. Instead, please use Read, Write and Append", "en"),
    /**
     * An access mode indicating Read access
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    Read: new VocabTerm(_NS$2("Read"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("Read", "en")
        .addComment("An access mode indicating Read access", "en"),
    /**
     * An access mode indicating Write access
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    Write: new VocabTerm(_NS$2("Write"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("Write", "en")
        .addComment("An access mode indicating Write access", "en"),
    /**
     * An access mode indicating Append access. Append is a more limited form of Write in which data may only be added but not removed.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    Append: new VocabTerm(_NS$2("Append"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("Append", "en")
        .addComment("An access mode indicating Append access. Append is a more limited form of Write in which data may only be added but not removed.", "en"),
    // *******************
    // All the Properties.
    // *******************
    /**
     * The object of this relationship is the access control resource associated with the subject resource.
   This relationship is intended to be used as the rel type of a Link, via HTTP Link Headers rfc5988 for Linked Data resources.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    accessControl: new VocabTerm(_NS$2("accessControl"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("accessControl", "en")
        .addComment("The object of this relationship is the access control resource associated with the subject resource.\n This relationship is intended to be used as the rel type of a Link, via HTTP Link Headers rfc5988 for Linked Data resources.", "en"),
    /**
     * The access property identifies the access policies that apply to the ACR itself.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    access: new VocabTerm(_NS$2("access"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("access", "en")
        .addComment("The access property identifies the access policies that apply to the ACR itself.", "en"),
    /**
     * The accessLocked property identifies the access policies that apply to the ACR itself.
   These policies may not be removed except by an agent with write access to the root ACR.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    accessLocked: new VocabTerm(_NS$2("accessLocked"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("access locked", "en")
        .addComment("The accessLocked property identifies the access policies that apply to the ACR itself.\n These policies may not be removed except by an agent with write access to the root ACR.", "en"),
    /**
     * The accessProtected property identifies the access policies that apply to the ACR itself.
   These policies may not be removed except by an agent with write access to the ACR where the policy was initially applied.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    accessProtected: new VocabTerm(_NS$2("accessProtected"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("access protected", "en")
        .addComment("The accessProtected property identifies the access policies that apply to the ACR itself.\n These policies may not be removed except by an agent with write access to the ACR where the policy was initially applied.", "en"),
    /**
     * The accessMembers property identifies the access policies that apply to the ACR itself, recursively.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    accessMembers: new VocabTerm(_NS$2("accessMembers"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("access members", "en")
        .addComment("The accessMembers property identifies the access policies that apply to the ACR itself, recursively.", "en"),
    /**
     * The accessMembersLocked property identifies the access policies that apply to the ACR itself, recursively.
      These policies may not be removed except by an agent with write access to the root ACR.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    accessMembersLocked: new VocabTerm(_NS$2("accessMembersLocked"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("access members locked", "en")
        .addComment("The accessMembersLocked property identifies the access policies that apply to the ACR itself, recursively.\n    These policies may not be removed except by an agent with write access to the root ACR.", "en"),
    /**
     * The accessMembersProtected property identifies the access policies that apply to the ACR itself, recursively.
      These policies may not be removed except by an agent with write access to the ACR where the policy was initially applied.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    accessMembersProtected: new VocabTerm(_NS$2("accessMembersProtected"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("access members protected", "en")
        .addComment("The accessMembersProtected property identifies the access policies that apply to the ACR itself, recursively.\n    These policies may not be removed except by an agent with write access to the ACR where the policy was initially applied.", "en"),
    /**
     * The apply property indentifies the access policies to apply to a resource.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    apply: new VocabTerm(_NS$2("apply"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("apply", "en")
        .addComment("The apply property indentifies the access policies to apply to a resource.", "en"),
    /**
     * The applyProtected property identifies the access policies to apply to a resource's members recursively.
      These policies may not be removed except by an agent with write access to the ACR where the policy was initially applied.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    applyProtected: new VocabTerm(_NS$2("applyProtected"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("apply protected", "en")
        .addComment("The applyProtected property identifies the access policies to apply to a resource's members recursively.\n    These policies may not be removed except by an agent with write access to the ACR where the policy was initially applied.", "en"),
    /**
     * The applyLocked property identifies the access policies to apply to a resource's members recursively.
   These policies may not be removed except by an agent with write access to the root ACR.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    applyLocked: new VocabTerm(_NS$2("applyLocked"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("apply locked", "en")
        .addComment("The applyLocked property identifies the access policies to apply to a resource's members recursively.\n These policies may not be removed except by an agent with write access to the root ACR.", "en"),
    /**
     * The applyMembers property indentifies the access policies to apply to a resource's members recursively.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    applyMembers: new VocabTerm(_NS$2("applyMembers"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("apply members", "en")
        .addComment("The applyMembers property indentifies the access policies to apply to a resource's members recursively.", "en"),
    /**
     * The applyMembersProtected property identifies the access policies to apply to a resource's members recursively.
   These policies may not be removed except by an agent with write access to the ACR where the policy was initially applied.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    applyMembersProtected: new VocabTerm(_NS$2("applyMembersProtected"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("apply members protected", "en")
        .addComment("The applyMembersProtected property identifies the access policies to apply to a resource's members recursively.\n These policies may not be removed except by an agent with write access to the ACR where the policy was initially applied.", "en"),
    /**
     * The applyMembersLocked property identifies the access policies to apply to a resource's members recurseively.
   These policies may not be removed except by an agent with write access to the root ACR.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    applyMembersLocked: new VocabTerm(_NS$2("applyMembersLocked"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("apply members locked", "en")
        .addComment("The applyMembersLocked property identifies the access policies to apply to a resource's members recurseively.\n These policies may not be removed except by an agent with write access to the root ACR.", "en"),
    /**
     * The allOf property identifies a collection of Rules, each of which must match in order for the Policy to take effect.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    allOf: new VocabTerm(_NS$2("allOf"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("all of", "en")
        .addComment("The allOf property identifies a collection of Rules, each of which must match in order for the Policy to take effect.", "en"),
    /**
     * The anyOf property identifies a collection of Rules, one of which must match in order for the Policy to take effect.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    anyOf: new VocabTerm(_NS$2("anyOf"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("any of", "en")
        .addComment("The anyOf property identifies a collection of Rules, one of which must match in order for the Policy to take effect.", "en"),
    /**
     * The noneOf property identifies a collection of Rules, none of which must match in order for the Policy to take effect.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    noneOf: new VocabTerm(_NS$2("noneOf"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("none of", "en")
        .addComment("The noneOf property identifies a collection of Rules, none of which must match in order for the Policy to take effect.", "en"),
    /**
     * The allow property identifies the access modes a Policy allows.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    allow: new VocabTerm(_NS$2("allow"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("allow", "en")
        .addComment("The allow property identifies the access modes a Policy allows.", "en"),
    /**
     * The deny property identifies the access modes a Policy denies.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    deny: new VocabTerm(_NS$2("deny"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("deny", "en")
        .addComment("The deny property identifies the access modes a Policy denies.", "en"),
    /**
     * The agent property identifies the agent WebID(s) to which a Rule applies.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    agent: new VocabTerm(_NS$2("agent"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("agent", "en")
        .addComment("The agent property identifies the agent WebID(s) to which a Rule applies.", "en"),
    /**
     * The client property identifies the client WebID(s) to which a Rule applies.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    client: new VocabTerm(_NS$2("client"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("client", "en")
        .addComment("The client property identifies the client WebID(s) to which a Rule applies.", "en"),
    /**
     * The group property identifies the vcard group(s) to which a Rule applies.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/acp#
     */
    group: new VocabTerm(_NS$2("group"), rdfFactory$2, getLocalStore(), false)
        .addIsDefinedBy(_NS$2("http://www.w3.org/ns/solid/acp#"))
        .addLabel("group", "en")
        .addComment("The group property identifies the vcard group(s) to which a Rule applies.", "en"),
};

/**
 * MIT License
 *
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var rdfFactory$1 = new rdfDataFactory.DataFactory();
function _NS$1(localName) {
    return rdfFactory$1.namedNode("http://www.w3.org/ns/solid/terms#" + localName);
}
// Add 'any' type annotation in case this vocab includes 'NamedNode' instances,
// for example instances of Constant IRIs (TypeScript compiler will complain of
// "semantic error TS2742" otherwise).
/**
 * The Solid Terms vocabulary defines terms referenced in Solid specifications.
 */
var SOLID = {
    PREFIX: "solid",
    NAMESPACE: "http://www.w3.org/ns/solid/terms#",
    PREFIX_AND_NAMESPACE: { "solid": "http://www.w3.org/ns/solid/terms#" },
    NS: _NS$1,
    // *****************
    // All the Classes.
    // *****************
    /**
     * A Solid account.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    Account: new VocabTerm(_NS$1("Account"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Account", "en")
        .addComment("A Solid account.", "en"),
    /**
     * A resource containing notifications.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    Inbox: new VocabTerm(_NS$1("Inbox"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Inbox", "en")
        .addComment("A resource containing notifications.", "en"),
    /**
     * Listed Type Index is a registry of resources that are publicly discoverable by outside users and applications.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    ListedDocument: new VocabTerm(_NS$1("ListedDocument"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Listed Type Index", "en")
        .addComment("Listed Type Index is a registry of resources that are publicly discoverable by outside users and applications.", "en"),
    /**
     * A notification resource.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    Notification: new VocabTerm(_NS$1("Notification"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Notification", "en")
        .addComment("A notification resource.", "en"),
    /**
     * A patch expresses conditional modifications to a resource that has an RDF-based representation.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    Patch: new VocabTerm(_NS$1("Patch"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Patch", "en")
        .addComment("A patch expresses conditional modifications to a resource that has an RDF-based representation.", "en"),
    /**
     * A resource containing time ordered items and sub-containers.  Sub-containers may be desirable in file based systems to split the timeline into logical components e.g. /yyyy-mm-dd/ as used in ISO 8061.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    Timeline: new VocabTerm(_NS$1("Timeline"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Timeline", "en")
        .addComment("A resource containing time ordered items and sub-containers.  Sub-containers may be desirable in file based systems to split the timeline into logical components e.g. /yyyy-mm-dd/ as used in ISO 8061.", "en"),
    /**
     * A index of type registries for resources. Applications can register the RDF type they use and list them in the index resource.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    TypeIndex: new VocabTerm(_NS$1("TypeIndex"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Type index", "en")
        .addComment("A index of type registries for resources. Applications can register the RDF type they use and list them in the index resource.", "en"),
    /**
     * The registered types that map a RDF classes/types to their locations using either `instance` or `instanceContainer` property.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    TypeRegistration: new VocabTerm(_NS$1("TypeRegistration"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Type Registration", "en")
        .addComment("The registered types that map a RDF classes/types to their locations using either `instance` or `instanceContainer` property.", "en"),
    /**
     * Unlisted Type Index is a registry of resources that are private to the user and their apps, for types that are not publicly discoverable.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    UnlistedDocument: new VocabTerm(_NS$1("UnlistedDocument"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Unlisted Type Index", "en")
        .addComment("Unlisted Type Index is a registry of resources that are private to the user and their apps, for types that are not publicly discoverable.", "en"),
    /**
     * The class of WebIDs - where a WebID is an HTTP URI which refers to an Agent (Person, Organization, Device, etc.).
     *
     * Defined by the vocabulary: https://w3id.org/inrupt/vocab/extension/solid-terms#
     */
    WebId: new VocabTerm(_NS$1("WebId"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("https://w3id.org/inrupt/vocab/extension/solid-terms#"))
        .addLabel("Class of WebID", "en")
        .addComment("The class of WebIDs - where a WebID is an HTTP URI which refers to an Agent (Person, Organization, Device, etc.).", "en"),
    // *******************
    // All the Properties.
    // *******************
    /**
     * A solid account belonging to an Agent.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    account: new VocabTerm(_NS$1("account"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("account", "en")
        .addComment("A solid account belonging to an Agent.", "en"),
    /**
     * The triple patterns this patch removes from the document.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    deletes: new VocabTerm(_NS$1("deletes"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("deletes", "en")
        .addComment("The triple patterns this patch removes from the document.", "en"),
    /**
     * A class that is used to map an listed or unlisted type index.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    forClass: new VocabTerm(_NS$1("forClass"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("registry class", "en")
        .addComment("A class that is used to map an listed or unlisted type index.", "en"),
    /**
     * Deprecated pointer to a Linked Data Notifications inbox; please use http://www.w3.org/ns/ldp#inbox instead.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    inbox: new VocabTerm(_NS$1("inbox"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("inbox (deprecated)", "en")
        .addComment("Deprecated pointer to a Linked Data Notifications inbox; please use http://www.w3.org/ns/ldp#inbox instead.", "en"),
    /**
     * The triple patterns this patch adds to the document.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    inserts: new VocabTerm(_NS$1("inserts"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("inserts", "en")
        .addComment("The triple patterns this patch adds to the document.", "en"),
    /**
     * Maps a type to an individual resource, typically an index or a directory listing resource.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    instance: new VocabTerm(_NS$1("instance"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("instance", "en")
        .addComment("Maps a type to an individual resource, typically an index or a directory listing resource.", "en"),
    /**
     * Maps a type to a container which the client would have to list to get the instances of that type.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    instanceContainer: new VocabTerm(_NS$1("instanceContainer"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("instance container", "en")
        .addComment("Maps a type to a container which the client would have to list to get the instances of that type.", "en"),
    /**
     * The login URI of a given server.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    loginEndpoint: new VocabTerm(_NS$1("loginEndpoint"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("loginEndpoint", "en")
        .addComment("The login URI of a given server.", "en"),
    /**
     * The logout URI of a given server.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    logoutEndpoint: new VocabTerm(_NS$1("logoutEndpoint"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("logoutEndpoint", "en")
        .addComment("The logout URI of a given server.", "en"),
    /**
     * Notification resource for an inbox.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    notification: new VocabTerm(_NS$1("notification"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("notification", "en")
        .addComment("Notification resource for an inbox.", "en"),
    /**
     * The preferred OpenID Connect issuer URI for a given WebID.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    oidcIssuer: new VocabTerm(_NS$1("oidcIssuer"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("OIDC issuer", "en")
        .addComment("The preferred OpenID Connect issuer URI for a given WebID.", "en"),
    /**
     * The document to which this patch applies.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    patches: new VocabTerm(_NS$1("patches"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("patches", "en")
        .addComment("The document to which this patch applies.", "en"),
    /**
     * Points to an unlisted type index resource.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    privateTypeIndex: new VocabTerm(_NS$1("privateTypeIndex"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("private type index", "en")
        .addComment("Points to an unlisted type index resource.", "en"),
    /**
     * Points to a listed type index resource.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    publicTypeIndex: new VocabTerm(_NS$1("publicTypeIndex"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("public type index", "en")
        .addComment("Points to a listed type index resource.", "en"),
    /**
     * Points to a TypeIndex resource.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    typeIndex: new VocabTerm(_NS$1("typeIndex"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("type index", "en")
        .addComment("Points to a TypeIndex resource.", "en"),
    /**
     * Indicates if a message has been read or not. This property should have a boolean datatype.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    read: new VocabTerm(_NS$1("read"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("read", "en")
        .addComment("Indicates if a message has been read or not. This property should have a boolean datatype.", "en"),
    /**
     * The quota of non-volatile memory that is available for the account (in bytes)
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    storageQuota: new VocabTerm(_NS$1("storageQuota"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Non-volatile memory quota", "en")
        .addComment("The quota of non-volatile memory that is available for the account (in bytes)", "en"),
    /**
     * The amount of non-volatile memory that the account have used (in bytes)
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    storageUsage: new VocabTerm(_NS$1("storageUsage"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("Non-volatile memory usage", "en")
        .addComment("The amount of non-volatile memory that the account have used (in bytes)", "en"),
    /**
     * Timeline for a given resource.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    timeline: new VocabTerm(_NS$1("timeline"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("timeline", "en")
        .addComment("Timeline for a given resource.", "en"),
    /**
     * The conditions the document and the inserted and deleted triple patterns need to satisfy in order for the patch to be applied.
     *
     * Defined by the vocabulary: http://www.w3.org/ns/solid/terms#
     */
    where: new VocabTerm(_NS$1("where"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("http://www.w3.org/ns/solid/terms#"))
        .addLabel("where", "en")
        .addComment("The conditions the document and the inserted and deleted triple patterns need to satisfy in order for the patch to be applied.", "en"),
    /**
     * A WebID is an HTTP URI which refers to an Agent (Person, Organization, Device, etc.).
     *
     * Defined by the vocabulary: https://w3id.org/inrupt/vocab/extension/solid-terms#
     */
    webId: new VocabTerm(_NS$1("webId"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("https://w3id.org/inrupt/vocab/extension/solid-terms#"))
        .addLabel("WebID", "en")
        .addComment("A WebID is an HTTP URI which refers to an Agent (Person, Organization, Device, etc.).", "en"),
    /**
     * The WebID of a 'Pod Owner', the person, organisation or agent deemed to be the owner of a Solid Pod.
     *
     * Defined by the vocabulary: https://w3id.org/inrupt/vocab/extension/solid-terms#
     */
    podOwner: new VocabTerm(_NS$1("podOwner"), rdfFactory$1, getLocalStore(), false)
        .addIsDefinedBy(_NS$1("https://w3id.org/inrupt/vocab/extension/solid-terms#"))
        .addLabel("Pod Owner", "en")
        .addComment("The WebID of a 'Pod Owner', the person, organisation or agent deemed to be the owner of a Solid Pod.", "en"),
};

/**
 * MIT License
 *
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var rdfFactory = new rdfDataFactory.DataFactory();
function _NS(localName) {
    return rdfFactory.namedNode("http://www.w3.org/ns/pim/space#" + localName);
}
// Add 'any' type annotation in case this vocab includes 'NamedNode' instances,
// for example instances of Constant IRIs (TypeScript compiler will complain of
// "semantic error TS2742" otherwise).
/**
 * This extension adds predicates making explicit some implicit knowledge in the Workspace ontology.
 */
var WS = {
    PREFIX: "ws",
    NAMESPACE: "http://www.w3.org/ns/pim/space#",
    PREFIX_AND_NAMESPACE: { "ws": "http://www.w3.org/ns/pim/space#" },
    NS: _NS,
    // *****************
    // All the Classes.
    // *****************
    /**
     * A file describing a configuration. In this context, it is
   expected to describe the workspace configuration.
     *
     * This term provides non-English descriptions, but a mismatch between labels and comments, with [1] label in the language [fr], but [0] comments.
     */
    ConfigurationFile: new VocabTerm(_NS("ConfigurationFile"), rdfFactory, getLocalStore(), false)
        .addLabel("Configuration file", "en")
        .addLabel("Fichier de configuration", "fr")
        .addComment("A file describing a configuration. In this context, it is\n expected to describe the workspace configuration.", "en"),
    /**
     * A  storage is a space of URIs in which you can individually control for each resource
      who has access to it.
  
     */
    ControlledStorage: new VocabTerm(_NS("ControlledStorage"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("access controlled storage")
        .addCommentNoLanguage("A  storage is a space of URIs in which you can individually control for each resource\n    who has access to it.\n"),
    /**
     * A storage is a space of URIs in which you have access to data.
  
     */
    Storage: new VocabTerm(_NS("Storage"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("storage")
        .addCommentNoLanguage("A storage is a space of URIs in which you have access to data.\n"),
    /**
     * This is a workspace for storing the
      information about the other workspaces.
      As a user, you normally don't have to worry about it.
     */
    MasterWorkspace: new VocabTerm(_NS("MasterWorkspace"), rdfFactory, getLocalStore(), false)
        .addLabel("Master Workspace", "en")
        .addCommentNoLanguage("This is a workspace for storing the \n    information about the other workspaces.\n    As a user, you normally don't have to worry about it."),
    /**
     * Access only by the you, the user.
     */
    PrivateWorkspace: new VocabTerm(_NS("PrivateWorkspace"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("Private workspace")
        .addCommentNoLanguage("Access only by the you, the user."),
    /**
     * Workspaces are place where data is stored, and associated polices of privacy.
  A given application typically stores information in several different
  workspaces, some being user private, some shared, and some public.
  
     */
    Workspace: new VocabTerm(_NS("Workspace"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("workspace")
        .addCommentNoLanguage("Workspaces are place where data is stored, and associated polices of privacy.\nA given application typically stores information in several different\nworkspaces, some being user private, some shared, and some public.\n"),
    /**
     * A personal storage is a space of URIs in which you and only you have access to data,
      you cannot give access to anyone else.
  
     */
    PersonalStorage: new VocabTerm(_NS("PersonalStorage"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("personal storage")
        .addCommentNoLanguage("A personal storage is a space of URIs in which you and only you have access to data,\n    you cannot give access to anyone else.\n"),
    /**
     * A public storage is a space of URIs in which you have access to data,
      and all data is accessible to anyone without control.
  
     */
    PublicStorage: new VocabTerm(_NS("PublicStorage"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("public storage")
        .addCommentNoLanguage("A public storage is a space of URIs in which you have access to data,\n    and all data is accessible to anyone without control.\n"),
    /**
     * Aceess is open to the public. Anything in a public workspace
      can be accesed by anyone.
     */
    PublicWorkspace: new VocabTerm(_NS("PublicWorkspace"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("Public workspace")
        .addCommentNoLanguage("Aceess is open to the public. Anything in a public workspace\n    can be accesed by anyone."),
    /**
     * AAceess may not be open to the public.
      Contains preferences resources
     */
    PreferencesWorkspace: new VocabTerm(_NS("PreferencesWorkspace"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("Preferences workspace")
        .addCommentNoLanguage("AAceess may not be open to the public. \n    Contains preferences resources"),
    /**
     * Access is to some but not all people.
     */
    SharedWorkspace: new VocabTerm(_NS("SharedWorkspace"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("Shared workspace")
        .addCommentNoLanguage("Access is to some but not all people."),
    // *******************
    // All the Properties.
    // *******************
    /**
     * master workspace
     */
    masterWorkspace: new VocabTerm(_NS("masterWorkspace"), rdfFactory, getLocalStore(), false)
        .addLabel("master workspace", "en"),
    /**
     * preferences file
     */
    preferencesFile: new VocabTerm(_NS("preferencesFile"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("preferences file"),
    /**
     * The storage in which this workspace is
     */
    storage: new VocabTerm(_NS("storage"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("storage")
        .addCommentNoLanguage("The storage in which this workspace is"),
    /**
     * URIs which start with this string are in this workspace or storage.
  This may be used for constructing URIs for new storage resources.
  
     */
    uriPrefix: new VocabTerm(_NS("uriPrefix"), rdfFactory, getLocalStore(), false)
        .addLabelNoLanguage("URI prefix")
        .addCommentNoLanguage("URIs which start with this string are in this workspace or storage.\nThis may be used for constructing URIs for new storage resources.\n"),
    /**
     * workspace
     */
    workspace: new VocabTerm(_NS("workspace"), rdfFactory, getLocalStore(), false)
        .addLabel("workspace", "en"),
};

export { ACL, ACP, SOLID, SOLID_META_ACL, SOLID_META_CLIENT, SOLID_META_SERVER_CREATIONAL, SOLID_META_SERVER_RUNTIME, SOLID_SERVICE_COMMON, WS };
