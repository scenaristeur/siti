import { posToDOMRect, Extension } from '@tiptap/core';
import { PluginKey, Plugin } from 'prosemirror-state';
import tippy from 'tippy.js';

class FloatingMenuView {
    constructor({ editor, element, view, tippyOptions, }) {
        this.preventHide = false;
        this.mousedownHandler = () => {
            this.preventHide = true;
        };
        this.focusHandler = () => {
            // we use `setTimeout` to make sure `selection` is already updated
            setTimeout(() => this.update(this.editor.view));
        };
        this.blurHandler = ({ event }) => {
            var _a;
            if (this.preventHide) {
                this.preventHide = false;
                return;
            }
            if ((event === null || event === void 0 ? void 0 : event.relatedTarget)
                && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
                return;
            }
            this.hide();
        };
        this.editor = editor;
        this.element = element;
        this.view = view;
        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });
        this.editor.on('focus', this.focusHandler);
        this.editor.on('blur', this.blurHandler);
        this.createTooltip(tippyOptions);
        this.element.style.visibility = 'visible';
    }
    createTooltip(options = {}) {
        this.tippy = tippy(this.view.dom, {
            duration: 0,
            getReferenceClientRect: null,
            content: this.element,
            interactive: true,
            trigger: 'manual',
            placement: 'right',
            hideOnClick: 'toggle',
            ...options,
        });
    }
    update(view, oldState) {
        const { state, composing } = view;
        const { doc, selection } = state;
        const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);
        if (composing || isSame) {
            return;
        }
        const { $anchor, empty, from, to, } = selection;
        const isRootDepth = $anchor.depth === 1;
        const isNodeEmpty = !selection.$anchor.parent.isLeaf && !selection.$anchor.parent.textContent;
        const isActive = isRootDepth && isNodeEmpty;
        if (!empty || !isActive) {
            this.hide();
            return;
        }
        this.tippy.setProps({
            getReferenceClientRect: () => posToDOMRect(view, from, to),
        });
        this.show();
    }
    show() {
        this.tippy.show();
    }
    hide() {
        this.tippy.hide();
    }
    destroy() {
        this.tippy.destroy();
        this.element.removeEventListener('mousedown', this.mousedownHandler);
        this.editor.off('focus', this.focusHandler);
        this.editor.off('blur', this.blurHandler);
    }
}
const FloatingMenuPluginKey = new PluginKey('menuFloating');
const FloatingMenuPlugin = (options) => {
    return new Plugin({
        key: FloatingMenuPluginKey,
        view: view => new FloatingMenuView({ view, ...options }),
    });
};

const FloatingMenu = Extension.create({
    name: 'bubbleMenu',
    defaultOptions: {
        element: null,
        tippyOptions: {},
    },
    addProseMirrorPlugins() {
        if (!this.options.element) {
            return [];
        }
        return [
            FloatingMenuPlugin({
                editor: this.editor,
                element: this.options.element,
                tippyOptions: this.options.tippyOptions,
            }),
        ];
    },
});

export default FloatingMenu;
export { FloatingMenu, FloatingMenuPlugin, FloatingMenuPluginKey, FloatingMenuView };
//# sourceMappingURL=tiptap-extension-floating-menu.esm.js.map
