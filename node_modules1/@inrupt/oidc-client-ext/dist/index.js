'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var oidcClient = require('oidc-client');
var nodeJose = require('node-jose');
var JWT = require('jsonwebtoken');
var uuid = require('uuid');
var formurlencoded = require('form-urlencoded');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var JWT__default = /*#__PURE__*/_interopDefaultLegacy(JWT);
var formurlencoded__default = /*#__PURE__*/_interopDefaultLegacy(formurlencoded);

function determineSigningAlg(supported, preferred) {
    var _a;
    return ((_a = preferred.find((signingAlg) => {
        return supported.includes(signingAlg);
    })) !== null && _a !== void 0 ? _a : null);
}
const PREFERRED_SIGNING_ALG = ["ES256", "RS256"];

function processErrorResponse(responseBody, options) {
    var _a, _b, _c, _d;
    if (responseBody.error === "invalid_redirect_uri") {
        throw new Error(`Dynamic client registration failed: the provided redirect uri [${(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()}] is invalid - ${(_b = responseBody.error_description) !== null && _b !== void 0 ? _b : ""}`);
    }
    if (responseBody.error === "invalid_client_metadata") {
        throw new Error(`Dynamic client registration failed: the provided client metadata ${JSON.stringify(options)} is invalid - ${(_c = responseBody.error_description) !== null && _c !== void 0 ? _c : ""}`);
    }
    throw new Error(`Dynamic client registration failed: ${responseBody.error} - ${(_d = responseBody.error_description) !== null && _d !== void 0 ? _d : ""}`);
}
function validateRegistrationResponse(responseBody, options) {
    if (responseBody.client_id === undefined) {
        throw new Error(`Dynamic client registration failed: no client_id has been found on ${JSON.stringify(responseBody)}`);
    }
    if (options.redirectUrl &&
        (responseBody.redirect_uris === undefined ||
            responseBody.redirect_uris[0] !== options.redirectUrl.toString())) {
        throw new Error(`Dynamic client registration failed: the returned redirect URIs ${JSON.stringify(responseBody.redirect_uris)} don't match the provided ${JSON.stringify([
            options.redirectUrl.toString(),
        ])}`);
    }
}
async function registerClient(options, issuerConfig) {
    var _a;
    if (!issuerConfig.registrationEndpoint) {
        throw new Error("Dynamic Registration could not be completed because the issuer has no registration endpoint.");
    }
    if (!Array.isArray(issuerConfig.idTokenSigningAlgValuesSupported)) {
        throw new Error("The OIDC issuer discovery profile is missing the 'id_token_signing_alg_values_supported' value, which is mandatory.");
    }
    const signingAlg = determineSigningAlg(issuerConfig.idTokenSigningAlgValuesSupported, PREFERRED_SIGNING_ALG);
    const config = {
        client_name: options.clientName,
        application_type: "web",
        redirect_uris: [(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()],
        subject_type: "pairwise",
        token_endpoint_auth_method: "client_secret_basic",
        id_token_signed_response_alg: signingAlg,
    };
    const headers = {
        "Content-Type": "application/json",
    };
    if (options.registrationAccessToken) {
        headers.Authorization = `Bearer ${options.registrationAccessToken}`;
    }
    const registerResponse = await fetch(issuerConfig.registrationEndpoint.toString(), {
        method: "POST",
        headers,
        body: JSON.stringify(config),
    });
    if (registerResponse.ok) {
        const responseBody = await registerResponse.json();
        validateRegistrationResponse(responseBody, options);
        return {
            clientId: responseBody.client_id,
            clientSecret: responseBody.client_secret,
            idTokenSignedResponseAlg: responseBody.id_token_signed_response_alg,
        };
    }
    if (registerResponse.status === 400) {
        processErrorResponse(await registerResponse.json(), options);
    }
    throw new Error(`Dynamic client registration failed: the server returned ${registerResponse.status} ${registerResponse.statusText} - ${await registerResponse.text()}`);
}

async function validateIdToken(token, rawJwks, issuer, audience) {
    const key = rawJwks.keys[0];
    const parsedKey = await nodeJose.JWK.asKey(key);
    try {
        JWT__default['default'].verify(token, parsedKey.toPEM(false), {
            issuer,
            audience,
            algorithms: ["ES256", "RS256"],
        });
    }
    catch (e) {
        return false;
    }
    return true;
}
async function signJwt(payload, key, options) {
    const parsedKey = await nodeJose.JWK.asKey(key);
    const convertedKey = parsedKey.toPEM(true);
    const signed = JWT__default['default'].sign(payload, convertedKey, options);
    return signed;
}
async function decodeJwt(token, key, options) {
    if (key) {
        const parsedKey = await nodeJose.JWK.asKey(key);
        const convertedKey = parsedKey.toPEM(false);
        return JWT__default['default'].verify(token, convertedKey, options);
    }
    return JWT__default['default'].decode(token);
}
async function privateJwkToPublicJwk(key) {
    return (await nodeJose.JWK.asKey(key, "public"));
}
function normalizeHttpUriClaim(audience) {
    const cleanedAudience = new URL(audience);
    cleanedAudience.hash = "";
    cleanedAudience.username = "";
    cleanedAudience.password = "";
    return cleanedAudience.toString();
}
async function createDpopHeader(audience, method, key) {
    return signJwt({
        htu: normalizeHttpUriClaim(audience),
        htm: method.toUpperCase(),
        jti: uuid.v4(),
    }, key, {
        header: {
            jwk: await privateJwkToPublicJwk(key),
            typ: "dpop+jwt",
        },
        algorithm: "ES256",
    });
}

async function generateJwk(kty, crvBitlength, parameters) {
    const key = await nodeJose.JWK.createKey(kty, crvBitlength, parameters);
    return key.toJSON(true);
}
async function generateJwkForDpop() {
    return generateJwk("EC", "P-256", { alg: "ES256" });
}
async function generateJwkRsa() {
    return generateJwk("RSA");
}

function hasError(value) {
    return value.error !== undefined && typeof value.error === "string";
}
function hasErrorDescription(value) {
    return (value.error_description !== undefined &&
        typeof value.error_description === "string");
}
function hasErrorUri(value) {
    return value.error_uri !== undefined && typeof value.error_uri === "string";
}
function hasAccessToken(value) {
    return (value.access_token !== undefined && typeof value.access_token === "string");
}
function hasIdToken(value) {
    return value.id_token !== undefined && typeof value.id_token === "string";
}
function hasRefreshToken(value) {
    return (value.refresh_token !== undefined && typeof value.refresh_token === "string");
}
function hasTokenType(value) {
    return value.token_type !== undefined && typeof value.token_type === "string";
}
function hasExpiresIn(value) {
    return value.expires_in === undefined || typeof value.expires_in === "number";
}
function isWebIdOidcIdToken(token) {
    return ((token.sub !== undefined &&
        typeof token.sub === "string" &&
        token.iss !== undefined &&
        typeof token.iss === "string" &&
        !token.webid) ||
        typeof token.webid === "string");
}
async function deriveWebIdFromIdToken(idToken) {
    const decoded = await decodeJwt(idToken);
    if (!isWebIdOidcIdToken(decoded)) {
        throw new Error(`Invalid ID token: ${JSON.stringify(decoded)} is missing 'sub' or 'iss' claims`);
    }
    if (decoded.webid) {
        return decoded.webid;
    }
    try {
        new URL(decoded.sub);
    }
    catch (error) {
        throw new Error(`Cannot extract WebID from ID token: the ID token returned by [${decoded.iss}] has no 'webid' claim, nor an IRI-like 'sub' claim: [${decoded.sub}]. Attempting to construct a URL from the 'sub' claim threw: ${error}`);
    }
    return decoded.sub;
}
function validatePreconditions(issuer, data) {
    if (data.grantType &&
        (!issuer.grantTypesSupported ||
            !issuer.grantTypesSupported.includes(data.grantType))) {
        throw new Error(`The issuer [${issuer.issuer}] does not support the [${data.grantType}] grant`);
    }
    if (!issuer.tokenEndpoint) {
        throw new Error(`This issuer [${issuer.issuer}] does not have a token endpoint`);
    }
}
function validateTokenEndpointResponse(tokenResponse, dpop) {
    if (hasError(tokenResponse)) {
        throw new Error(`Token endpoint returned error [${tokenResponse.error}]${hasErrorDescription(tokenResponse)
            ? `: ${tokenResponse.error_description}`
            : ""}${hasErrorUri(tokenResponse) ? ` (see ${tokenResponse.error_uri})` : ""}`);
    }
    if (!hasAccessToken(tokenResponse)) {
        throw new Error(`Invalid token endpoint response (missing the field 'access_token'): ${JSON.stringify(tokenResponse)}`);
    }
    if (!hasIdToken(tokenResponse)) {
        throw new Error(`Invalid token endpoint response (missing the field 'id_token'): ${JSON.stringify(tokenResponse)}.`);
    }
    if (!hasTokenType(tokenResponse)) {
        throw new Error(`Invalid token endpoint response (missing the field 'token_type'): ${JSON.stringify(tokenResponse)}`);
    }
    if (!hasExpiresIn(tokenResponse)) {
        throw new Error(`Invalid token endpoint response (invalid field 'expires_in'): ${JSON.stringify(tokenResponse)}`);
    }
    if (!dpop && tokenResponse.token_type.toLowerCase() !== "bearer") {
        throw new Error(`Invalid token endpoint response: requested a [Bearer] token, but got a 'token_type' value of [${tokenResponse.token_type}].`);
    }
    return tokenResponse;
}
async function getTokens(issuer, client, data, dpop) {
    validatePreconditions(issuer, data);
    const headers = {
        "content-type": "application/x-www-form-urlencoded",
    };
    let dpopJwk;
    if (dpop) {
        dpopJwk = await generateJwkForDpop();
        headers.DPoP = await createDpopHeader(issuer.tokenEndpoint, "POST", dpopJwk);
    }
    if (client.clientSecret) {
        headers.Authorization = `Basic ${btoa(`${client.clientId}:${client.clientSecret}`)}`;
    }
    const tokenRequestInit = {
        method: "POST",
        headers,
        body: formurlencoded__default['default']({
            grant_type: data.grantType,
            redirect_uri: data.redirectUrl,
            code: data.code,
            code_verifier: data.codeVerifier,
            client_id: client.clientId,
        }),
    };
    const rawTokenResponse = (await (await fetch(issuer.tokenEndpoint, tokenRequestInit)).json());
    const tokenResponse = validateTokenEndpointResponse(rawTokenResponse, dpop);
    const webId = await deriveWebIdFromIdToken(tokenResponse.id_token);
    return {
        accessToken: tokenResponse.access_token,
        idToken: tokenResponse.id_token,
        refreshToken: hasRefreshToken(tokenResponse)
            ? tokenResponse.refresh_token
            : undefined,
        webId,
        dpopJwk,
        expiresIn: tokenResponse.expires_in,
    };
}
async function getBearerToken(redirectUrl) {
    let signinResponse;
    try {
        signinResponse = await new oidcClient.OidcClient({
            response_mode: "query",
            loadUserInfo: false,
        }).processSigninResponse(redirectUrl);
    }
    catch (err) {
        throw new Error(`Problem handling Auth Code Grant (Flow) redirect - URL [${redirectUrl}]: ${err}`);
    }
    const webId = await deriveWebIdFromIdToken(signinResponse.id_token);
    return {
        accessToken: signinResponse.access_token,
        idToken: signinResponse.id_token,
        webId,
        refreshToken: signinResponse.refresh_token,
    };
}
async function getDpopToken(issuer, client, data) {
    return getTokens(issuer, client, data, true);
}

function removeOidcQueryParam(redirectUrl) {
    const cleanedUrl = new URL(redirectUrl);
    cleanedUrl.searchParams.delete("code");
    cleanedUrl.searchParams.delete("state");
    cleanedUrl.hash = "";
    return cleanedUrl.toString();
}
async function clearOidcPersistentStorage() {
    const client = new oidcClient.OidcClient({
        response_mode: "query",
    });
    await client.clearStaleState(new oidcClient.WebStorageStateStore({}));
    const myStorage = window.localStorage;
    const itemsToRemove = [];
    for (let i = 0; i <= myStorage.length; i += 1) {
        const key = myStorage.key(i);
        if (key &&
            (key.match(/^oidc\..+$/) ||
                key.match(/^solidClientAuthenticationUser:.+$/))) {
            itemsToRemove.push(key);
        }
    }
    itemsToRemove.forEach((key) => myStorage.removeItem(key));
}

Object.defineProperty(exports, 'CordovaIFrameNavigator', {
  enumerable: true,
  get: function () {
    return oidcClient.CordovaIFrameNavigator;
  }
});
Object.defineProperty(exports, 'CordovaPopupNavigator', {
  enumerable: true,
  get: function () {
    return oidcClient.CordovaPopupNavigator;
  }
});
Object.defineProperty(exports, 'InMemoryWebStorage', {
  enumerable: true,
  get: function () {
    return oidcClient.InMemoryWebStorage;
  }
});
Object.defineProperty(exports, 'Log', {
  enumerable: true,
  get: function () {
    return oidcClient.Log;
  }
});
Object.defineProperty(exports, 'OidcClient', {
  enumerable: true,
  get: function () {
    return oidcClient.OidcClient;
  }
});
Object.defineProperty(exports, 'SessionMonitor', {
  enumerable: true,
  get: function () {
    return oidcClient.SessionMonitor;
  }
});
Object.defineProperty(exports, 'User', {
  enumerable: true,
  get: function () {
    return oidcClient.User;
  }
});
Object.defineProperty(exports, 'UserManager', {
  enumerable: true,
  get: function () {
    return oidcClient.UserManager;
  }
});
Object.defineProperty(exports, 'Version', {
  enumerable: true,
  get: function () {
    return oidcClient.Version;
  }
});
Object.defineProperty(exports, 'WebStorageStateStore', {
  enumerable: true,
  get: function () {
    return oidcClient.WebStorageStateStore;
  }
});
exports.clearOidcPersistentStorage = clearOidcPersistentStorage;
exports.createDpopHeader = createDpopHeader;
exports.decodeJwt = decodeJwt;
exports.generateJwkForDpop = generateJwkForDpop;
exports.generateJwkRsa = generateJwkRsa;
exports.getBearerToken = getBearerToken;
exports.getDpopToken = getDpopToken;
exports.privateJwkToPublicJwk = privateJwkToPublicJwk;
exports.registerClient = registerClient;
exports.removeOidcQueryParam = removeOidcQueryParam;
exports.signJwt = signJwt;
exports.validateIdToken = validateIdToken;
